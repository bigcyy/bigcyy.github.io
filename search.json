[{"title":"Mybatis使用入门","url":"/2021/09/98c8042a4fb6.html","content":"快速入门1.导入maven坐标（jar包）\n   -msql驱动\n&lt;dependency&gt;    &lt;groupId&gt;mysql&lt;/groupId&gt;    &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;    &lt;version&gt;8.0.25&lt;/version&gt;&lt;/dependency&gt;\n\n\n   -mybatis\n&lt;!-- https://mvnrepository.com/artifact/org.mybatis/mybatis --&gt;&lt;dependency&gt;    &lt;groupId&gt;org.mybatis&lt;/groupId&gt;    &lt;artifactId&gt;mybatis&lt;/artifactId&gt;    &lt;version&gt;3.5.7&lt;/version&gt;&lt;/dependency&gt;\n\n\n2.创建表以及实体类\nUSE test;CREATE TABLE `user`(`id` INT PRIMARY KEY AUTO_INCREMENT,`username` VARCHAR(15),`password` VARCHAR(15))INSERT INTO `user`(`username`,`p`USER`assword`) VALUES(&#x27;cyy&#x27;,&#x27;123456&#x27;);INSERT INTO `user` (`username`,`password`) VALUES(&#x27;hi&#x27;,&#x27;123456&#x27;);INSERT INTO `user` (`username`,`password`) VALUES(&#x27;jjb&#x27;,&#x27;123456&#x27;);\n\npublic class User &#123;    private Integer id;    private String username;    private String password;    public User() &#123;    &#125;    public Integer getId() &#123;        return id;    &#125;    public void setId(Integer id) &#123;        this.id = id;    &#125;    public String getUsername() &#123;        return username;    &#125;    public void setUsername(String username) &#123;        this.username = username;    &#125;    public String getPassword() &#123;        return password;    &#125;    public void setPassword(String password) &#123;        this.password = password;    &#125;    @Override    public String toString() &#123;        return &quot;User&#123;&quot; +                &quot;id=&quot; + id +                &quot;, username=&#x27;&quot; + username + &#x27;\\&#x27;&#x27; +                &quot;, password=&#x27;&quot; + password + &#x27;\\&#x27;&#x27; +                &#x27;&#125;&#x27;;    &#125;&#125;\n\n\n3.编写映射文件xxxmapper.xml\n&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE mapper        PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;        &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;&lt;mapper namespace=&quot;userMapper&quot;&gt;    &lt;select id=&quot;findAll&quot; resultType=&quot;com.study.pojo.User&quot;&gt;        select * from user    &lt;/select&gt;    &lt;insert id=&quot;sava&quot; parameterType=&quot;com.study.pojo.User&quot;&gt;        insert into user values(#&#123;id&#125;,#&#123;username&#125;,#&#123;password&#125;)    &lt;/insert&gt;    &lt;delete id=&quot;deleteUser&quot; parameterType=&quot;java.lang.Integer&quot;&gt;        delete from user where id = #&#123;id&#125;    &lt;/delete&gt;    &lt;update id=&quot;updateUser&quot; parameterType=&quot;com.study.pojo.User&quot;&gt;        update user set username=#&#123;username&#125;,password=#&#123;password&#125; where id=#&#123;id&#125;    &lt;/update&gt;&lt;/mapper&gt;\n\n\n4.编写mybatis核心配置\n&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE configuration        PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot;        &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;&lt;configuration&gt;    &lt;!--配置数据源环境--&gt;    &lt;environments default=&quot;development&quot;&gt;        &lt;environment id=&quot;development&quot;&gt;            &lt;transactionManager type=&quot;JDBC&quot;&gt;&lt;/transactionManager&gt;            &lt;dataSource type=&quot;POOLED&quot;&gt;                &lt;property name=&quot;driver&quot; value=&quot;com.mysql.jdbc.Driver&quot;/&gt;                &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql:///test&quot;/&gt;                &lt;property name=&quot;username&quot; value=&quot;root&quot;/&gt;                &lt;property name=&quot;password&quot; value=&quot;root&quot;/&gt;            &lt;/dataSource&gt;        &lt;/environment&gt;    &lt;/environments&gt;    &lt;!--加载映射文件--&gt;    &lt;mappers&gt;        &lt;mapper resource=&quot;com/study/mapper/userMapper.xml&quot;&gt;&lt;/mapper&gt;    &lt;/mappers&gt;&lt;/configuration&gt;\n\n\n5.进行测试\npackage com.study.test;import com.study.pojo.User;import org.apache.ibatis.io.Resources;import org.apache.ibatis.session.SqlSession;import org.apache.ibatis.session.SqlSessionFactory;import org.apache.ibatis.session.SqlSessionFactoryBuilder;import org.junit.Test;import java.io.IOException;import java.io.InputStream;import java.util.List;/** * @Auther: cyy * @Date: 2021/9/17 22 57 * @Description:测试mybatis的增加删改，未进行抽取 */public class MybatisTest &#123;    //查    @Test    public void test1() throws IOException &#123;        //加载核心配置文件        InputStream resourceAsStream = Resources.getResourceAsStream(&quot;sqlMapConfig.xml&quot;);        //获得sqlSession工厂        SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(resourceAsStream);        //获得sqlSession对象        SqlSession sqlSession = sqlSessionFactory.openSession();        //执行操作        List&lt;User&gt; users = sqlSession.selectList(&quot;userMapper.findAll&quot;);        System.out.println(users);        sqlSession.close();    &#125;    @Test    public void test2() throws IOException &#123;        //删        InputStream resourceAsStream = Resources.getResourceAsStream(&quot;sqlMapConfig.xml&quot;);        SqlSessionFactory factory = new SqlSessionFactoryBuilder().build(resourceAsStream);        SqlSession sqlSession = factory.openSession();        sqlSession.delete(&quot;userMapper.deleteUser&quot;,new Integer(8));        sqlSession.commit();        sqlSession.close();    &#125;    @Test    public void test3() throws IOException &#123;        //增        User user = new User();        user.setUsername(&quot;gg4&quot;);        user.setPassword(&quot;123456&quot;);        InputStream resourceAsStream = Resources.getResourceAsStream(&quot;sqlMapConfig.xml&quot;);        SqlSessionFactory factory = new SqlSessionFactoryBuilder().build(resourceAsStream);        SqlSession sqlSession = factory.openSession();        sqlSession.insert(&quot;userMapper.sava&quot;,user);        sqlSession.commit();        sqlSession.close();    &#125;    @Test    public void test4() throws IOException &#123;        //改        User user = new User();        user.setId(10);        user.setUsername(&quot;bb4&quot;);        user.setPassword(&quot;654321&quot;);        InputStream resourceAsStream = Resources.getResourceAsStream(&quot;sqlMapConfig.xml&quot;);        SqlSessionFactory factory = new SqlSessionFactoryBuilder().build(resourceAsStream);        SqlSession sqlSession = factory.openSession();        sqlSession.update(&quot;userMapper.updateUser&quot;,user);        sqlSession.commit();        sqlSession.close();    &#125;&#125;\n\n\n\nmybatis传统实现1.数据库和pojo同上\n2.dao层\n   -接口\npackage com.study.mapper;import com.study.pojo.User;import java.io.IOException;import java.util.List;/** * @Auther: cyy * @Date: 2021/9/22 22 53 * @Description: */public interface UserMapper &#123;    public List&lt;User&gt; findAll() throws IOException;    public User findOneById(Integer id) throws IOException;    public void saveUser(User user) throws IOException;    public void deleteUser(Integer id) throws IOException;    public void updateUser(User newUser) throws IOException;&#125;\n\n\n   -对应实现\npackage com.study.mapper.impl;import com.study.mapper.UserMapper;import com.study.pojo.User;import org.apache.ibatis.io.Resources;import org.apache.ibatis.session.SqlSession;import org.apache.ibatis.session.SqlSessionFactory;import org.apache.ibatis.session.SqlSessionFactoryBuilder;import java.io.IOException;import java.io.InputStream;import java.util.List;/** * @Auther: cyy * @Date: 2021/9/22 23 01 * @Description: */public class UserMapperImpl implements UserMapper &#123;    @Override    public List&lt;User&gt; findAll() throws IOException &#123;        InputStream resourceAsStream = Resources.getResourceAsStream(&quot;sqlMapConfig.xml&quot;);        SqlSessionFactory build = new SqlSessionFactoryBuilder().build(resourceAsStream);        SqlSession sqlSession = build.openSession();        return sqlSession.selectList(&quot;userMapper.findAll&quot;);    &#125;    @Override    public User findOneById(Integer id) throws IOException &#123;        InputStream resourceAsStream = Resources.getResourceAsStream(&quot;sqlMapConfig.xml&quot;);        SqlSessionFactory build = new SqlSessionFactoryBuilder().build(resourceAsStream);        SqlSession sqlSession = build.openSession();        return sqlSession.selectOne(&quot;userMapper.findOneById&quot;,id);    &#125;    @Override    public void saveUser(User user) throws IOException &#123;        InputStream resourceAsStream = Resources.getResourceAsStream(&quot;sqlMapConfig.xml&quot;);        SqlSessionFactory build = new SqlSessionFactoryBuilder().build(resourceAsStream);        SqlSession sqlSession = build.openSession();        sqlSession.insert(&quot;userMapper.saveUser&quot;,user);        sqlSession.commit();    &#125;    @Override    public void deleteUser(Integer id) throws IOException &#123;        InputStream resourceAsStream = Resources.getResourceAsStream(&quot;sqlMapConfig.xml&quot;);        SqlSessionFactory build = new SqlSessionFactoryBuilder().build(resourceAsStream);        SqlSession sqlSession = build.openSession();        sqlSession.delete(&quot;userMapper.deleteUser&quot;,id);        sqlSession.commit();    &#125;    @Override    public void updateUser(User newUser) throws IOException &#123;        InputStream resourceAsStream = Resources.getResourceAsStream(&quot;sqlMapConfig.xml&quot;);        SqlSessionFactory build = new SqlSessionFactoryBuilder().build(resourceAsStream);        SqlSession sqlSession = build.openSession();        sqlSession.update(&quot;userMapper.updateUser&quot;,newUser);        sqlSession.commit();    &#125;&#125;\n\n\n3.mybatis映射文件\n&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE mapper        PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;        &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;&lt;mapper namespace=&quot;userMapper&quot;&gt;    &lt;select id=&quot;findAll&quot; resultType=&quot;com.study.pojo.User&quot;&gt;        select * from user    &lt;/select&gt;    &lt;select id=&quot;findOneById&quot; parameterType=&quot;int&quot; resultType=&quot;com.study.pojo.User&quot;&gt;        select * from user where id=#&#123;id&#125;;    &lt;/select&gt;    &lt;insert id=&quot;saveUser&quot; parameterType=&quot;com.study.pojo.User&quot;&gt;        insert into user values(#&#123;id&#125;,#&#123;username&#125;,#&#123;password&#125;)    &lt;/insert&gt;    &lt;delete id=&quot;deleteUser&quot; parameterType=&quot;int&quot;&gt;        delete from user where id = #&#123;ids&#125;    &lt;/delete&gt;    &lt;update id=&quot;updateUser&quot; parameterType=&quot;com.study.pojo.User&quot;&gt;        update user set username=#&#123;username&#125;,password=#&#123;password&#125; where id=#&#123;id&#125;    &lt;/update&gt;&lt;/mapper&gt;\n\n\n4.测试dao层\npackage com.study.mapper.impl;import com.study.mapper.UserMapper;import com.study.pojo.User;import org.junit.jupiter.api.Test;import java.io.IOException;import static org.junit.jupiter.api.Assertions.*;class UserMapperImplTest &#123;    UserMapper userMapper = new UserMapperImpl();    @Test    void findAll() throws IOException &#123;        System.out.println(userMapper.findAll());    &#125;    @Test    void findOneById() throws IOException &#123;        System.out.println(userMapper.findOneById(1));    &#125;    @Test    void saveUser() throws IOException &#123;        User user = new User();        user.setUsername(&quot;gg23232&quot;);        user.setPassword(&quot;hha333hd&quot;);        userMapper.saveUser(user);    &#125;    @Test    void deleteUser() throws IOException &#123;        userMapper.deleteUser(10);    &#125;    @Test    void updateUser() throws IOException &#123;        User user = new User();        user.setId(9);        user.setUsername(&quot;ggg&quot;);        user.setPassword(&quot;hhasdha&quot;);        userMapper.updateUser(user);    &#125;&#125;\n\n\n\nmybatis接口代理方式实现\n注意：映射xml文件里的namespace属性值要是接口的全类名，\n\n\n映射xml文件里的sql语句id属性值要与接口方法对应\n\n1.数据库和pojo同上\n2.dao层接口\npackage com.study.mapper;import com.study.pojo.User;import java.io.IOException;import java.util.List;/** * @Auther: cyy * @Date: 2021/9/22 22 53 * @Description: */public interface UserMapper &#123;    public List&lt;User&gt; findAll() throws IOException;    public User findOneById(Integer id) throws IOException;    public void saveUser(User user) throws IOException;    public void deleteUser(Integer id) throws IOException;    public void updateUser(User newUser) throws IOException;&#125;\n\n\n3.mybatis映射文件\n&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE mapper        PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;        &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;&lt;mapper namespace=&quot;com.study.mapper.UserMapper&quot;&gt;    &lt;select id=&quot;findAll&quot; resultType=&quot;com.study.pojo.User&quot;&gt;        select * from user    &lt;/select&gt;    &lt;select id=&quot;findOneById&quot; parameterType=&quot;int&quot; resultType=&quot;com.study.pojo.User&quot;&gt;        select * from user where id=#&#123;id&#125;;    &lt;/select&gt;    &lt;insert id=&quot;saveUser&quot; parameterType=&quot;com.study.pojo.User&quot;&gt;        insert into user values(#&#123;id&#125;,#&#123;username&#125;,#&#123;password&#125;)    &lt;/insert&gt;    &lt;delete id=&quot;deleteUser&quot; parameterType=&quot;int&quot;&gt;        delete from user where id = #&#123;ids&#125;    &lt;/delete&gt;    &lt;update id=&quot;updateUser&quot; parameterType=&quot;com.study.pojo.User&quot;&gt;        update user set username=#&#123;username&#125;,password=#&#123;password&#125; where id=#&#123;id&#125;    &lt;/update&gt;&lt;/mapper&gt;\n\n\n4.测试\npackage com.study.mapper;import com.study.pojo.User;import org.apache.ibatis.io.Resources;import org.apache.ibatis.session.SqlSession;import org.apache.ibatis.session.SqlSessionFactory;import org.apache.ibatis.session.SqlSessionFactoryBuilder;import org.junit.jupiter.api.Test;import org.springframework.core.io.Resource;import org.w3c.dom.ls.LSOutput;import java.io.IOException;import java.io.InputStream;import static org.junit.jupiter.api.Assertions.*;class UserMapperTest &#123;    @Test    void findAll() throws IOException &#123;        InputStream resourceAsStream = Resources.getResourceAsStream(&quot;sqlMapConfig.xml&quot;);        SqlSessionFactory build = new SqlSessionFactoryBuilder().build(resourceAsStream);        SqlSession sqlSession = build.openSession();        UserMapper mapper = sqlSession.getMapper(UserMapper.class);        System.out.println(mapper.findAll());    &#125;    @Test    void findOneById() throws IOException &#123;        InputStream resourceAsStream = Resources.getResourceAsStream(&quot;sqlMapConfig.xml&quot;);        SqlSessionFactory build = new SqlSessionFactoryBuilder().build(resourceAsStream);        SqlSession sqlSession = build.openSession();        UserMapper mapper = sqlSession.getMapper(UserMapper.class);        System.out.println(mapper.findOneById(1));    &#125;    @Test    void saveUser() throws IOException &#123;        User user = new User();        user.setUsername(&quot;gg22&quot;);        user.setPassword(&quot;hha&quot;);        InputStream resourceAsStream = Resources.getResourceAsStream(&quot;sqlMapConfig.xml&quot;);        SqlSessionFactory build = new SqlSessionFactoryBuilder().build(resourceAsStream);        SqlSession sqlSession = build.openSession();        UserMapper mapper = sqlSession.getMapper(UserMapper.class);        mapper.saveUser(user);        sqlSession.commit();    &#125;    @Test    void deleteUser() throws IOException &#123;        InputStream resourceAsStream = Resources.getResourceAsStream(&quot;sqlMapConfig.xml&quot;);        SqlSessionFactory build = new SqlSessionFactoryBuilder().build(resourceAsStream);        SqlSession sqlSession = build.openSession();        UserMapper mapper = sqlSession.getMapper(UserMapper.class);        mapper.deleteUser(12);        sqlSession.commit();    &#125;    @Test    void updateUser() throws IOException &#123;        User user = new User();        user.setId(9);        user.setUsername(&quot;gg22&quot;);        user.setPassword(&quot;hha&quot;);        InputStream resourceAsStream = Resources.getResourceAsStream(&quot;sqlMapConfig.xml&quot;);        SqlSessionFactory build = new SqlSessionFactoryBuilder().build(resourceAsStream);        SqlSession sqlSession = build.openSession();        UserMapper mapper = sqlSession.getMapper(UserMapper.class);        mapper.updateUser(user);        sqlSession.commit();    &#125;&#125;\n\n\n","categories":["笔记"],"tags":["Java","框架","Mybatis"]},{"title":"SSM整合记录","url":"/2021/09/9541285f7bbe.html","content":"1.导入坐标\n&lt;dependencies&gt;        &lt;!--spring相关--&gt;        &lt;!--spring上下文--&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework&lt;/groupId&gt;            &lt;artifactId&gt;spring-context&lt;/artifactId&gt;            &lt;version&gt;5.2.3.RELEASE&lt;/version&gt;        &lt;/dependency&gt;        &lt;!--动态代理--&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.aspectj&lt;/groupId&gt;            &lt;artifactId&gt;aspectjweaver&lt;/artifactId&gt;            &lt;version&gt;1.9.7&lt;/version&gt;        &lt;/dependency&gt;        &lt;!--jdbc模板--&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework&lt;/groupId&gt;            &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt;            &lt;version&gt;5.2.3.RELEASE&lt;/version&gt;        &lt;/dependency&gt;        &lt;!--事务控制--&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework&lt;/groupId&gt;            &lt;artifactId&gt;spring-tx&lt;/artifactId&gt;            &lt;version&gt;5.2.3.RELEASE&lt;/version&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework&lt;/groupId&gt;            &lt;artifactId&gt;spring-test&lt;/artifactId&gt;            &lt;version&gt;5.2.3.RELEASE&lt;/version&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework&lt;/groupId&gt;            &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt;            &lt;version&gt;5.2.3.RELEASE&lt;/version&gt;        &lt;/dependency&gt;        &lt;!--servlet和jsp--&gt;        &lt;dependency&gt;            &lt;groupId&gt;javax.servlet&lt;/groupId&gt;            &lt;artifactId&gt;servlet-api&lt;/artifactId&gt;            &lt;version&gt;2.5&lt;/version&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;javax.servlet.jsp&lt;/groupId&gt;            &lt;artifactId&gt;jsp-api&lt;/artifactId&gt;            &lt;version&gt;2.2.1-b03&lt;/version&gt;        &lt;/dependency&gt;        &lt;!--mybatis相关--&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.mybatis&lt;/groupId&gt;            &lt;artifactId&gt;mybatis&lt;/artifactId&gt;            &lt;version&gt;3.5.7&lt;/version&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.mybatis&lt;/groupId&gt;            &lt;artifactId&gt;mybatis-spring&lt;/artifactId&gt;            &lt;version&gt;1.3.1&lt;/version&gt;        &lt;/dependency&gt;        &lt;!--mysql驱动--&gt;        &lt;dependency&gt;            &lt;groupId&gt;mysql&lt;/groupId&gt;            &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;            &lt;version&gt;8.0.25&lt;/version&gt;        &lt;/dependency&gt;        &lt;!--数据源--&gt;        &lt;dependency&gt;            &lt;groupId&gt;com.mchange&lt;/groupId&gt;            &lt;artifactId&gt;c3p0&lt;/artifactId&gt;            &lt;version&gt;0.9.5.5&lt;/version&gt;        &lt;/dependency&gt;        &lt;!--junit单元测试--&gt;        &lt;dependency&gt;            &lt;groupId&gt;junit&lt;/groupId&gt;            &lt;artifactId&gt;junit&lt;/artifactId&gt;            &lt;version&gt;4.13.1&lt;/version&gt;            &lt;scope&gt;test&lt;/scope&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;jstl&lt;/groupId&gt;            &lt;artifactId&gt;jstl&lt;/artifactId&gt;            &lt;version&gt;1.2&lt;/version&gt;        &lt;/dependency&gt;    &lt;/dependencies&gt;\n\n\n2.创建数据库表以及实体\nCREATE DATABASE ssm;USE ssm;CREATE TABLE account(    id INT PRIMARY KEY AUTO_INCREMENT,    `name` VARCHAR(100),    money DOUBLE(7,2));\n\npackage com.study.domain;/** * @Auther: cyy * @Date: 2021/9/25 09 39 * @Description: 实体 */public class Account &#123;    private Integer id;    private String name;    private Double money;    public Account() &#123;    &#125;    public Account(Integer id, String name, Double money) &#123;        this.id = id;        this.name = name;        this.money = money;    &#125;    public Integer getId() &#123;        return id;    &#125;    public void setId(Integer id) &#123;        this.id = id;    &#125;    public String getName() &#123;        return name;    &#125;    public void setName(String name) &#123;        this.name = name;    &#125;    public Double getMoney() &#123;        return money;    &#125;    public void setMoney(Double money) &#123;        this.money = money;    &#125;    @Override    public String toString() &#123;        return &quot;Account&#123;&quot; +                &quot;id=&quot; + id +                &quot;, name=&#x27;&quot; + name + &#x27;\\&#x27;&#x27; +                &quot;, money=&quot; + money +                &#x27;&#125;&#x27;;    &#125;&#125;\n\n\n3.dao层和service层controller架构搭建\n4.前端页面\n   -保存界面\n&lt;%--  Created by IntelliJ IDEA.  User: cyy  Date: 2021/9/25  Time: 10:00  To change this template use File | Settings | File Templates.--%&gt;&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;html&gt;&lt;head&gt;    &lt;title&gt;add&lt;/title&gt;&lt;/head&gt;&lt;body&gt;    &lt;h1&gt;添加账户信息&lt;/h1&gt;    &lt;form name=&quot;accountForm&quot; action=&quot;$&#123;pageContext.request.contextPath&#125;/account/save&quot; method=&quot;post&quot;&gt;        账户名称:&lt;input type=&quot;text&quot; name=&quot;name&quot;&gt;&lt;br&gt;        账号金额:&lt;input type=&quot;text&quot; name=&quot;money&quot;&gt;&lt;br&gt;        &lt;input type=&quot;submit&quot; value=&quot;保存&quot;&gt;&lt;br&gt;    &lt;/form&gt;&lt;/body&gt;&lt;/html&gt;\n\n\n   -清单界面\n&lt;%@ taglib prefix=&quot;c&quot; uri=&quot;http://java.sun.com/jsp/jstl/core&quot; %&gt;&lt;%--  Created by IntelliJ IDEA.  User: cyy  Date: 2021/9/25  Time: 10:05  To change this template use File | Settings | File Templates.--%&gt;&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;html&gt;&lt;head&gt;    &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;    &lt;h1&gt;展示&lt;/h1&gt;    &lt;table&gt;      &lt;tr&gt;        &lt;th&gt;账户id&lt;/th&gt;        &lt;th&gt;账户名称&lt;/th&gt;        &lt;th&gt;账户金额&lt;/th&gt;      &lt;/tr&gt;      &lt;c:forEach items=&quot;$&#123;accountList&#125;&quot; var=&quot;account&quot;&gt;        &lt;tr&gt;          &lt;th&gt;$&#123;account.id&#125;&lt;/th&gt;          &lt;th&gt;$&#123;account.name&#125;&lt;/th&gt;          &lt;th&gt;$&#123;account.money&#125;&lt;/th&gt;        &lt;/tr&gt;      &lt;/c:forEach&gt;    &lt;/table&gt;&lt;/body&gt;&lt;/html&gt;\n\n\n5.配置文件\n   -数据库连接相关信息：jdbc.properties\njdbc.username=rootjdbc.password=rootjdbc.url=jdbc:mysql://localhost:3306/ssmjdbc.driver=com.mysql.cj.jdbc.Driver\n\n\n   -日志文件：log4j.xml\n### direct log messages to stdout ###log4j.appender.stdout=org.apache.log4j.ConsoleAppenderlog4j.appender.stdout.Target=System.outlog4j.appender.stdout.layout=org.apache.log4j.PatternLayoutlog4j.appender.stdout.layout.ConversionPattern=%d&#123;ABSOLUTE&#125; %5p %c&#123;1&#125;:%L - %m%n### direct messages to file mylog.log ###log4j.appender.file=org.apache.log4j.FileAppenderlog4j.appender.file.File=c:/mylog.loglog4j.appender.file.layout=org.apache.log4j.PatternLayoutlog4j.appender.file.layout.ConversionPattern=%d&#123;ABSOLUTE&#125; %5p %c&#123;1&#125;:%L - %m%n### set log levels - for more verbose logging change &#x27;info&#x27; to &#x27;debug&#x27; ###log4j.rootLogger=info, stdout\n\n\n   -web.xml(web目录下)\n&lt;!DOCTYPE web-app PUBLIC &quot;-//Sun Microsystems, Inc.//DTD Web Application 2.3//EN&quot; &quot;http://java.sun.com/dtd/web-app_2_3.dtd&quot; &gt;&lt;web-app xmlns=&quot;http://xmlns.jcp.org/xml/ns/javaee&quot;         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;         xsi:schemaLocation=&quot;http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd&quot;         version=&quot;4.0&quot;&gt;  &lt;display-name&gt;Archetype Created Web Application&lt;/display-name&gt;  &lt;!--配置spring监听器--&gt;  &lt;context-param&gt;    &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;    &lt;param-value&gt;classpath:applicationContext.xml&lt;/param-value&gt;  &lt;/context-param&gt;  &lt;listener&gt;    &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt;  &lt;/listener&gt;  &lt;!--spring MVC前端控制器--&gt;  &lt;servlet&gt;    &lt;servlet-name&gt;dispatcherServlet&lt;/servlet-name&gt;    &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt;    &lt;init-param&gt;      &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;      &lt;param-value&gt;classpath:spring-mvc.xml&lt;/param-value&gt;    &lt;/init-param&gt;    &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;  &lt;/servlet&gt;    &lt;servlet-mapping&gt;    &lt;servlet-name&gt;dispatcherServlet&lt;/servlet-name&gt;    &lt;url-pattern&gt;/&lt;/url-pattern&gt;  &lt;/servlet-mapping&gt;  &lt;!--配置乱码过滤器--&gt;  &lt;filter&gt;    &lt;filter-name&gt;characterEncodingFilter&lt;/filter-name&gt;    &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt;    &lt;init-param&gt;      &lt;param-name&gt;encoding&lt;/param-name&gt;      &lt;param-value&gt;UTF-8&lt;/param-value&gt;    &lt;/init-param&gt;  &lt;/filter&gt;  &lt;filter-mapping&gt;    &lt;filter-name&gt;characterEncodingFilter&lt;/filter-name&gt;    &lt;url-pattern&gt;/*&lt;/url-pattern&gt;  &lt;/filter-mapping&gt;&lt;/web-app&gt;\n\n\n   -spring应用上下文：applicationContext.xml\n&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;       xmlns:context=&quot;http://www.springframework.org/schema/context&quot;       xmlns:tx=&quot;http://www.springframework.org/schema/tx&quot;       xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot;       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd       http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd       http://www.springframework.org/schema/tx https://www.springframework.org/schema/tx/spring-tx.xsd       http://www.springframework.org/schema/aop https://www.springframework.org/schema/aop/spring-aop.xsd&quot;&gt;    &lt;!--开启组件扫描，主要扫描service层和dao层--&gt;    &lt;context:component-scan base-package=&quot;com.study&quot;&gt;        &lt;context:exclude-filter type=&quot;annotation&quot; expression=&quot;org.springframework.stereotype.Controller&quot;/&gt;    &lt;/context:component-scan&gt;    &lt;!--读取配置文件--&gt;    &lt;context:property-placeholder location=&quot;classpath:jdbc.properties&quot;/&gt;    &lt;!--配置数据源--&gt;    &lt;bean id=&quot;dataSource&quot; class=&quot;com.mchange.v2.c3p0.ComboPooledDataSource&quot;&gt;        &lt;property name=&quot;driverClass&quot; value=&quot;$&#123;jdbc.driver&#125;&quot;/&gt;        &lt;property name=&quot;jdbcUrl&quot; value=&quot;$&#123;jdbc.url&#125;&quot;/&gt;        &lt;property name=&quot;user&quot; value=&quot;$&#123;jdbc.username&#125;&quot;/&gt;        &lt;property name=&quot;password&quot; value=&quot;$&#123;jdbc.password&#125;&quot;/&gt;    &lt;/bean&gt;    &lt;!--配置mybatis的sqlSessionFactory--&gt;    &lt;bean id=&quot;sessionFactory&quot; class=&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;&gt;        &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;/&gt;        &lt;property name=&quot;configLocation&quot; value=&quot;classpath:sqlMapConfig.xml&quot;/&gt;    &lt;/bean&gt;    &lt;!--配置映射扫描,为mapper创建实现类--&gt;    &lt;bean id=&quot;mapperScanner&quot; class=&quot;org.mybatis.spring.mapper.MapperScannerConfigurer&quot;&gt;        &lt;property name=&quot;basePackage&quot; value=&quot;com.study.mapper&quot;/&gt;    &lt;/bean&gt;    &lt;!--配置jdbc事务管理--&gt;    &lt;!--配置事务管理器--&gt;    &lt;bean id=&quot;transactionManager&quot; class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt;        &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;/&gt;    &lt;/bean&gt;    &lt;!--配置事务增强--&gt;    &lt;tx:advice id=&quot;txAdvice&quot; transaction-manager=&quot;transactionManager&quot;&gt;        &lt;tx:attributes&gt;            &lt;tx:method name=&quot;find&quot; read-only=&quot;true&quot;/&gt;            &lt;tx:method name=&quot;*&quot; isolation=&quot;DEFAULT&quot;/&gt;        &lt;/tx:attributes&gt;    &lt;/tx:advice&gt;        &lt;!--aop织入--&gt;    &lt;aop:config&gt;        &lt;aop:advisor advice-ref=&quot;txAdvice&quot; pointcut=&quot;execution(* com.study.service.impl.*ServiceImpl.*(..))&quot;/&gt;    &lt;/aop:config&gt;&lt;/beans&gt;\n\n\n   -springmvc配置文件：spring-mvc.xml\n&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;       xmlns:context=&quot;http://www.springframework.org/schema/context&quot;       xmlns:mvc=&quot;http://www.springframework.org/schema/mvc&quot;       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd       http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd       http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc.xsd&quot;&gt;    &lt;!--开启组件扫描--&gt;    &lt;context:component-scan base-package=&quot;com.study.controller&quot;&gt;&lt;/context:component-scan&gt;    &lt;!--配置mvc注解驱动--&gt;    &lt;mvc:annotation-driven&gt;&lt;/mvc:annotation-driven&gt;    &lt;!--内部视图资源解析器--&gt;    &lt;bean id=&quot;resourceViewResolver&quot; class=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;&gt;        &lt;property name=&quot;prefix&quot; value=&quot;/WEB-INF/page/&quot;&gt;&lt;/property&gt;        &lt;property name=&quot;suffix&quot; value=&quot;.jsp&quot;&gt;&lt;/property&gt;    &lt;/bean&gt;    &lt;!--开放静态资源--&gt;    &lt;mvc:default-servlet-handler&gt;&lt;/mvc:default-servlet-handler&gt;&lt;/beans&gt;\n\n\n   -mybatis核心配置文件：sqlMapConfig.xml\n&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE configuration        PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot;        &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;&lt;configuration&gt;    &lt;!--扫包模式起别名--&gt;    &lt;typeAliases&gt;        &lt;package name=&quot;com.study.domain&quot;/&gt;    &lt;/typeAliases&gt;&lt;/configuration&gt;\n\n\n","categories":["笔记"],"tags":["Java","框架"]},{"title":"Hello World","url":"/2022/06/81aef93f8778.html","content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.\nQuick StartCreate a new post$ hexo new &quot;My New Post&quot;\n\nMore info: Writing\nRun server$ hexo server\n\nMore info: Server\nGenerate static files$ hexo generate\n\nMore info: Generating\nDeploy to remote sites$ hexo deploy\n\nMore info: Deployment\n","categories":["test"]},{"title":"基于Mirai的健康系统催签到以及信息推送机器人","url":"/2021/09/f9e657a65597.html","content":"使用方法\n催签到功能(详细介绍回复“催签到介绍”)：\n\n\n群里发送：”催签到”\n群里发送：@bot”登录”\n\n\n信息推送功能(详细介绍回复“信息推送介绍”): \n群里或者私聊发送:”添加推送好友:好友qq号”\n群里或者私聊发送:”删除推送好友:好友qq号”\n群里或者私聊发送:”添加推送子群:qq群号”\n群里或者私聊发送:”删除推送子群:qq群号”\n群里或者私聊发送:”查看推送目标”\n群里或者私聊发送:”开始推送”\n群里或者私聊发送:”结束推送”\n群里@全体成员自动推送\n\n\n查看使用方法:\n\n\n群里或者私聊发送:”使用方法”,或者直接戳一戳机器人\n\n\n动态开启以上功能(仅限机器人master)\n\n\n开启&#x2F;关闭催签到功能\n开启&#x2F;关闭自动催签到\n开启&#x2F;关闭登录\n开启&#x2F;关闭加好友\n开启&#x2F;关闭加群\n开启&#x2F;关闭信息推送\n\n\n机器人管理命令(仅限机器人master):\n查看状态命令:&#x2F;status\n查看文件夹命令:&#x2F;查看文件夹  文件夹\n查看文件内容命令:&#x2F;查看文件 文件夹 文件\n删除文件夹命令:&#x2F;删除文件夹 文件\n删除文件命令:&#x2F;删除文件 文件夹 文件\n通知命令:&#x2F;通知 通知内容\n\n\n\n催签到功能介绍面向用户成都师范学院(暂时未适配其他学校)\n模块\n手动催签到模块:\n在群里发送”催签到”,机器人将会@未签到的同学，@信息将会在90分钟后自动撤回\n\n\n自动催签到模块:\n机器人将在每天的9.00,11.00,12.00,13.00,14.00,15.00自动@未签到同学\n\n\n登录模块 :\n在群里@机器人并回复登录进行登录，登录成功后才可进行催签到，当多人同时进行登录时，可能需要进行排队等待，根据提示操作即可。\n\n\n\n使用方法\n联系我(1597081640)，提供您的学院，专业信息，以及辅导员健康系统的账号和密码 \n等待我添加配置文件后，将机器人拉入学院或班级或专业群 \n@机器人”登录”,进行首次登录 \n登录完成后即可使用\n\n\n注:目前仅适配成都师范学院\n\n信息推送功能介绍面向用户社团部门负责人，辅导员，班委，干事，希望对多个群信息进行整合的同学\n使用情景\n当你需要发送通知时，你是否因为要通知多个群，而进行重复的复制粘贴，使用信息推送功能，你只需向机器人发送一次通知，机器人便可以将通知信息发给你需要通知的所有群，具体操作请看以下动图\n\n\n\n你是否因为通知群太多时常置顶十几个群？使用信息推送功能，机器人将会把各通知群里的信息合并推送给你(这需要构建一个生态)，你只需要查看机器人给你发送的信息即可！具体操作请看以下动图\n\n\n\n将专业群里配置班级小群@全体同学的重要信息自动推送到配置的班级小群\n\n使用方法(建议先了解下面的几个名词)\n先确定你要以怎样的形式进行信息推送，在群里进行信息推送？或者私聊机器人进行信息推送\n设置推送对象，群里或者私聊发送：“添加推送子群:qq群号”，“添加推送好友:好友qq号”\n群里或者私聊发送：“开始推送”，开启信息推送\n群里或者私聊发送“结束推送”，结束信息推送\n一旦在群里配置了推送目标，@全体成员的信息就会自动推送到推送目标\n如果需要删除子群或者推送好友私聊发送：“删除推送子群:qq群号”来删除子群;“删除推送好友:好友qq号”来删除推送好友\n\n补充基础名词信息源,待推送信息，推送目标\n\n信息源:指待推送信息的来源，可以为一个群，和个人。当你在群里进行信息推送时，信息源就是该群，当你在打开和机器人的聊天窗口进行信息推送时，信息源就是你本人。 \n待推送信息:支持普通文本，图片，文件(目前仅支持群-&gt;群),语音(目前仅支持本人-&gt;好友，群-&gt;群) \n推送目标：群和好友\n\n\n注:信息源和推送目标是通过机器人联系起来的，将待推送信息从群-&gt;群，群-&gt;好友，本人-&gt;好友。所以需要邀请机器人进入群，加机器人为好友。希望你我一起构建信息推送的生态\n\n","categories":["个人项目"],"tags":["mirai","qq机器人"]},{"title":"记录一次博客折腾","url":"/2024/11/d69d3978dd5d.html","content":"使用的技术\nhexo+github pages静态托管+语雀写markdown+github actions自动化部署+腾讯云cos图片存储+hexo-yuque\n\n技术点介绍\nhexo\n\n快速简洁高效,多插件,多主题,基于node.js的博客框架。我们使用它来搭建我们的博客。\n\n\ngithub pages\n\ngithub提供的静态页面,您和您的项目的网站。直接从您的GitHub存储库托管。只需编辑、推送，您的更改就会实时进行更新。我们使用它来进行博客网站托管(白嫖github服务器)\n\n\n语雀\n\n新一代云端知识库，语雀自研编辑器，支持文档、表格、演示文稿、绘图四大文稿类型，具备 Markdown、代码块、LaTeX 公式、PlantUML 等专业编辑能力，同时支持本地视频、Office 文件、PDF 文件等内容的上传与在线预览，可满足多种专业岗位需求，让创作更高效。我们使用语雀来进行博客文章的编写。\n\n\ngithub actions\n\nGitHub Actions 可让您轻松自动化所有软件工作流程，直接从 GitHub 构建、测试和部署您的代码。我们使用它来讲博客源码自动化部署到github psges\n\n\n腾讯云cos\n\n安全稳定、低成本的海量云端存储服务,我们用它来存储图片\n\n\nhexo-yuque\n\nA downloader for articles from yuque（语雀知识库同步工具）我们使用它将记录在语雀上的博客同步到博客中\n\n\n\n技术点之间的联系","categories":["杂文"],"tags":["blog"]},{"title":"2024-Oceanbase数据库大赛总结","url":"/2025/03/98435b47a7a2.html","content":"前言我有幸参加了 2024 Oceanbase 数据库大赛，在初赛中从 1212 名参赛者中脱颖而出，获得第 30 名的成绩，成功晋级决赛。在决赛阶段，我们团队一度保持在前十的位置，然而在最后一周，由于项目组的紧急任务和期末考试的双重压力，我们放缓了比赛节奏。眼看排名尚可，我们选择了暂缓投入，不料在最后两天排名迅速下滑至第 21 位。为挽回局面，我们进行了最后一次提交，却因测试的随机性因素，获得了所有提交中最不理想的结果，最终排名第 24，遗憾地与二十强擦肩而过。\n这场比赛历时约两个月，分为初赛和决赛两个阶段。初赛基于开源的 MiniOB 数据库平台，要求参赛者实现数据库的基础功能；决赛则基于 Oceanbase 社区版源码，挑战我们优化现有的向量检索流程，以提升检索效率。\n初赛在初赛阶段，我主要负责实现以下数据库核心功能：\n\n日期类型的支持与处理\n\n基于 like&#x2F;not like 关键字的模糊匹配功能\n\n表达式计算与优化\n\n聚合函数的设计与实现\n\n多字段索引的构建与维护\n\n简单及复杂子查询的处理\n\n唯一索引的实现与约束\n\nSQL 查询中的别名支持\n\n向量索引的设计与实现\n\n视图(create view)的创建与管理\n\n\n决赛决赛设置了四个关键优化指标：\n\nAnnbenchmark 基准测试：针对无过滤条件、limit 固定为 10 的一系列查询，优化查询的每秒处理量(QPS)\n\nQ1 优化：针对无过滤条件但 limit 不固定的向量查询\n\nQ2 优化：针对有过滤条件(查询 id 列)且 limit 不固定的查询\n\nQ3 优化：针对有过滤条件(查询 id 列和 col1 列)且 limit 不固定的查询\n\n\n收获这次比赛让我收获颇丰，深入学习了多方面的数据库技术：\n\n数据库底层查询执行引擎的设计模型，包括火山模型和向量化执行引擎\n\nAI 领域关键技术——向量检索，特别是 HNSW 算法、向量底层存储机制以及向量索引构建方法\n\nSQL 完整执行流程：从 SQL 解析到 ParseNode，再到 Statement，继而转化为逻辑计划和物理计划，最终从存储层提取数据到上层的全过程\n\n代码性能测试技术，尤其是火焰图的应用\n\n代码性能优化策略，包括 CPU 优化、缓存优化和 I&#x2F;O 减少\n\n多线程编程技术的实践与巩固\n\nC++基础语法的应用与提升\n\n过滤下推等高级查询优化技术\n\n\n通过这次比赛，我不仅提升了技术能力，也深刻体会到了团队协作和时间管理的重要性。虽然与理想的名次有所差距，但这段经历无疑为我的技术成长奠定了坚实基础。\n","categories":["Oceanbase"],"tags":["#Oceanbase","#数据库","#比赛"]},{"title":"火山模型和数据库向量化执行引擎","url":"/2025/03/5a4d92542c4f.html","content":"火山模型将查询计划拆解为多个算子，每个算子有通用的三个接口（open，close，next）。一个查询计划被算子组成一颗算子树，算子树先自顶向下的调用 open 接口打开每个算子，然后调用 next 自顶向下拉取数据，最后调用 close 自顶向下关闭算子。\n举个例子\nSELECT name FROM users WHERE age &gt; 30;\n\n这个查询计划会被拆解为顶层的 Project（映射算子，负责将下层的一行数据映射出需要的 name 列的数据），Filter（过滤算子，用于过滤下层的一行数据，在例子中用于判断 age 是否大于 30），Scan（表扫描算子，用于从底层获取一行数据）。\n向量化执行引擎对火山模型的优化，在火山模型中 next 接口只吐出一行数据，而向量化执行引擎中 next 接口返回的是多行数据。提升了整个系统的吞吐量。\n优点在于\n\n可以用上 simd 指令\n批量处理数据时，连续的内存访问模式能更好地利用 CPU 缓存（Cache Locality），减少缓存未命中（Cache Miss）。\n\n","categories":["Oceanbase"],"tags":["#Oceanbase","#数据库","#火山模型","#向量化执行引擎"]},{"title":"kafka在windows环境下集群部署","url":"/2024/04/bb7507685b1a.html","content":"下载 kafka 安装包下载地址：Kafka\n下载后在 E 盘下新建文件夹 kafka-cluster ，将下载的压缩包解压到 kafka-cluster 目录下并复制 4 份 ，分别改名为，kafka-zk，kafka1，kafka2，kafka3。\n\nkafka-zk： 统一 kafka 节点的 zookeeper ，因为 kafka 内置了 ZooKeeper 软件，所以此处将解压缩的文件作为 ZooKeeper 软件使用。\nkafka1： 表示第一个节点。\nkafka2： 表示第二个节点。\nkafka3： 表示第三个节点。\n\n修改配置修改 kafka-zk/config/zookeeper.properties 文件下的内容\ndataDir=E:/kafka-cluster/kafka-zk/data\n\n修改 kafka1/config/server.properties 文件下的内容\nbroker.id=1listeners=PLAINTEXT://:9091log.dirs=E:/kafka-cluster/kafka1/data\n\n修改 kafka2/config/server.properties 文件下的内容\nbroker.id=2listeners=PLAINTEXT://:9092log.dirs=E:/kafka-cluster/kafka2/data\n\n修改 kafka3/config/server.properties 文件下的内容\nbroker.id=3listeners=PLAINTEXT://:9093log.dirs=E:/kafka-cluster/kafka3/data\n\n封装启动脚本（1）封装 zookeeper 启动脚本\n在 kafka-zk 文件夹下新建 zk.cmd 文件\ncall bin/windows/zookeeper-server-start.bat config/zookeeper.properties\n\n（2）封装 kafka 启动脚本\n在 kafka1，kafka2，kafka3 新建 kafka.cmd 文件\ncall bin/windows/kafka-server-start.bat config/server.properties\n\n（3）封装集群启动脚本\n在 kafka-cluster 目录下新建 cluster.cmd 文件\ncd kafka-zkstart zk.cmdping 127.0.0.1 -n 10 &gt;nulcd ../kafka1start kafka.cmdcd ../kafka2start kafka.cmdcd ../kafka3start kafka.cmd\n\n在 kafka-cluster 目录下新建 cluster-clear.cmd 文件用于清除 kafka 运行产生的数据\ncd kafka-zkrd /s /q datacd ../kafka1rd /s /q datacd ../kafka2rd /s /q datacd ../kafka3rd /s /q data\n\n启动脚本启动 cluster.cmd 脚本就可以启动集群服务了。\n","categories":["大数据"],"tags":["#kafka","#大数据","部署"]},{"title":"分布式锁的两种实现方式浅谈","url":"/2024/11/61113d0d4b06.html","content":"在分布式系统中，多个客户端可能会并发地访问临界资源。为了避免资源冲突和数据不一致，我们通常需要使用分布式锁来控制对共享资源的访问。分布式锁的本质就是排队，确保只有一个客户端可以访问资源，其他客户端需要等待。当访问完成时，锁会被释放，允许其他客户端依次访问资源。\n本文将分别介绍如何利用 Zookeeper 和 Redis 实现分布式锁，并分析它们的特点和应用场景。\nZookeeper 实现分布式锁Zookeeper 是一个高可靠的分布式协调框架，它提供了强一致性的节点管理功能，能够很好地支持分布式锁的实现。Zookeeper 的节点创建和监听机制可以模拟出一个排队的过程，从而确保在分布式系统中客户端能够按顺序访问临界资源。\n入队过程Zookeeper 的节点创建操作实际上就是将客户端加入队列。例如，假设有三个客户端需要访问某个临界资源，客户端 1 会首先创建一个临时顺序节点，Zookeeper 会为它分配一个序号，表明它在队列中的位置。客户端 2 和客户端 3 会依次创建节点，Zookeeper 会为每个客户端分配一个唯一的顺序号，这样就完成了入队的过程。\nClient 1 -&gt; /lock/0000000001Client 2 -&gt; /lock/0000000002Client 3 -&gt; /lock/0000000003\n\n每个客户端的节点都具有一个唯一的序号，从而可以按照序号来判断它们在队列中的位置。\n出队过程在队列中，队首的客户端拥有访问临界资源的权利。当队首的客户端访问完资源后，它会删除自己在 Zookeeper 中创建的临时节点，从而完成出队操作。然后，新的队首客户端就可以开始访问资源。\nClient 1 -&gt; /lock/0000000001 (访问资源)Client 1 删除节点 -&gt; 出队Client 2 -&gt; /lock/0000000002 (访问资源)\n\n通过删除临时节点，Zookeeper 实现了客户端之间的出队操作。此时，客户端 2 成为新的队首，继续访问资源。\n队首切换为了实现自动切换队首，客户端在创建节点时会监听自己前一个节点的删除事件。具体而言，当客户端创建节点后，会监听它前一个节点的状态。如果前一个节点被删除，意味着它已经完成了对资源的访问，当前客户端就可以获得访问资源的权限。\n这种机制利用了 Zookeeper 的 Watcher 机制，确保了分布式锁的公平性和顺序性。\nClient 2 在创建节点时监听 /lock/0000000001Client 1 删除节点 -&gt; Client 2 收到回调 -&gt; Client 2 访问资源\n\n通过这种方式，Zookeeper 可以有效地管理客户端的访问顺序，实现公平的分布式锁。\nZookeeper 分布式锁的优缺点优点：\n\n公平性：Zookeeper 可以保证客户端按照创建节点的顺序访问临界资源，确保分布式锁的公平性。\n可靠性：Zookeeper 提供强一致性的保证，确保锁机制在集群中的可靠性。\n\n缺点：\n\n性能瓶颈：由于 Zookeeper 是基于磁盘存储的，频繁的节点创建和删除可能会带来性能瓶颈。\n复杂性：Zookeeper 实现分布式锁需要较为复杂的节点管理和事件监听机制，对于一些简单的应用场景可能不太适合。\n\nRedis 实现分布式锁与 Zookeeper 相比，Redis 实现分布式锁更加轻量级，且通常用于不需要严格排队和公平性的场景。Redis 利用其高效的内存存储和命令执行特性，可以实现简单而高效的分布式锁机制。\n实现原理在 Redis 中，我们可以使用 SET NX PX 命令来实现分布式锁。该命令会尝试将一个指定的键（锁标识）设置为一个值。如果该键不存在，则设置成功，表示当前客户端获得了锁；如果键已经存在，则表示资源被其他客户端占用，当前客户端无法获得锁。\nSET lock_key unique_value NX PX 30000\n\n其中：\n\nNX：表示只有在键不存在时才会设置成功，保证了锁的互斥性。\nPX：表示设置键值对的过期时间，避免死锁的发生。\n\n死锁防止为了防止死锁，我们通常会给锁设置一个过期时间。这样，当客户端在持有锁时，如果由于某种原因未能及时释放锁，Redis 会自动删除该锁，从而避免锁永远不被释放的情况发生。\nRedis 分布式锁的优缺点优点：\n\n高效性：Redis 是基于内存的，操作非常高效，能够承受较高的并发请求。\n简单易用：相比 Zookeeper，Redis 的 API 简单，易于实现。\n\n缺点：\n\n缺乏公平性：Redis 的分布式锁并不保证客户端按顺序访问资源，某些客户端可能会频繁获取锁，而其他客户端可能一直处于等待状态。\n需要额外处理死锁：虽然 Redis 提供了过期时间机制，但如果客户端未能正确释放锁，仍然有可能出现死锁，需要额外的处理逻辑来避免这种情况。\n\n总结适用场景\nZookeeper：适用于需要高可靠性、强一致性和公平性的场景，尤其适合需要排队访问的应用。它能够确保客户端按照顺序访问资源，但性能上可能受到一些限制，尤其是在高并发场景下。\nRedis：适用于高性能要求的场景，尤其是对锁的竞争较少、没有严格顺序要求的应用。Redis 锁实现简单且高效，但不保证公平性，可能会导致锁的“饥饿”问题。\n\n在实际应用中，选择 Zookeeper 还是 Redis 取决于具体的业务需求和系统架构。如果系统中有复杂的分布式协调需求，Zookeeper 更为合适；如果系统需要高并发且对锁的顺序要求不高，Redis 是更好的选择。\n希望本文能帮助您更好地理解 Zookeeper 和 Redis 实现分布式锁的原理，并为您的项目提供一定的技术参考。\n","categories":["微服务"]},{"title":"微服务事务","url":"/2024/11/645e9be13a8a.html","content":"什么是微服务事务在某个微服务业务中，业务需要对数据库进行多次操作，其中对数据库的操作又由其他微服务业务完成，这整个业务所涉及的数据库操作需要同时成功或者同时失败。\n微服务事务和单体架构的事务有何区别在传统微服务业务中，对数据库的操作都包含在同一个数据库，可以依靠数据库自带的事务进行管理。在微服务中，每一个微服务都会对应自己的数据库，因此业务对数据库的操作涉及多个微服务业务对其自己的数据库进行操作。这时无法依靠数据库自带的事务进行处理。\n微服务事务的处理架构seata 架构\n三个角色和两种模式\n\nTM（Transaction Manager）：事务管理，通知 TC 开启与结束一个事务，或者回滚事务\nRM（Resource Manager）：分支事务管理，主要功能是注册子事务，报告子事务状态（成功&#x2F;失败），接收 TC 的命令执行提交或回滚。\nTC（Transaction Coordinator）：事务协调器，独立的微服务，维护事务的运行状态根据 TM 的指示开启事务记录以及事务完成后检查事务涉及的分支事务是否全部成功完成，若全部成功完成执行提交，若未成功完成执行回滚。\n例子\n如下图的订单业务，订单业务中需要生成订单，清除购物车，扣除库存。生成订单的操作和订单业务同属一个微服务，操作的同一个数据库。但是清除购物车的操作属于购物车微服务，操作的数据库和生成订单业务操作的数据库不同。扣除库存操作同理。\n\nAT 模式在 AT 工作模式下，订单业务开始时，TM 会通知 TC 开启一个事务，随后依次执行生产订单，清除购物车，扣除库存子业务。当执行生成订单操作时，RM 会向 TC 发起注册通知，表面子业务开始执行，当执行完后立即提交此子业务的事务，然后生成undo log（非 mysql 的 undo log），再通知 TC 子业务执行完成。其他子业务同理。\n最后订单业务执行完成后，TM 通知 TC 业务执行完毕，TC 这时检查每个分支事务执行情况，若有一个执行失败则发通知给 RM，令其根据 undo log 进行回滚。若均执行成功则会删除 undo log\nAT 模式的优点是性能高，其缺点是一致性差，由于分支事务完成后立即提交，若后续的分支事务出现错误，在这个过程中其他业务所得到的数据结果是脏数据，只有等回滚后数据才是正确的，因此AT 模式只能保证结果一致性。\nXA 模式XA 模式和 AT模式的主要区别在于，其子业务执行后不会立即提交，因此也不会生成 undo log（非 mysql 的 undo log），等整个业务完成后，依靠 TC 的通知决定回滚还是统一提交。\n所以其优点是数据一致性高，但其缺点也很明显，它的性能低。\nSeata 在 SpringBoot 中的集成部署 TC\n\n准备数据库表\n\nCREATE DATABASE IF NOT EXISTS `seata`;USE `seata`;CREATE TABLE IF NOT EXISTS `global_table`(    `xid`                       VARCHAR(128) NOT NULL,    `transaction_id`            BIGINT,    `status`                    TINYINT      NOT NULL,    `application_id`            VARCHAR(32),    `transaction_service_group` VARCHAR(32),    `transaction_name`          VARCHAR(128),    `timeout`                   INT,    `begin_time`                BIGINT,    `application_data`          VARCHAR(2000),    `gmt_create`                DATETIME,    `gmt_modified`              DATETIME,    PRIMARY KEY (`xid`),    KEY `idx_status_gmt_modified` (`status` , `gmt_modified`),    KEY `idx_transaction_id` (`transaction_id`)) ENGINE = InnoDB  DEFAULT CHARSET = utf8mb4;CREATE TABLE IF NOT EXISTS `branch_table`(    `branch_id`         BIGINT       NOT NULL,    `xid`               VARCHAR(128) NOT NULL,    `transaction_id`    BIGINT,    `resource_group_id` VARCHAR(32),    `resource_id`       VARCHAR(256),    `branch_type`       VARCHAR(8),    `status`            TINYINT,    `client_id`         VARCHAR(64),    `application_data`  VARCHAR(2000),    `gmt_create`        DATETIME(6),    `gmt_modified`      DATETIME(6),    PRIMARY KEY (`branch_id`),    KEY `idx_xid` (`xid`)) ENGINE = InnoDB  DEFAULT CHARSET = utf8mb4;CREATE TABLE IF NOT EXISTS `lock_table`(    `row_key`        VARCHAR(128) NOT NULL,    `xid`            VARCHAR(128),    `transaction_id` BIGINT,    `branch_id`      BIGINT       NOT NULL,    `resource_id`    VARCHAR(256),    `table_name`     VARCHAR(32),    `pk`             VARCHAR(36),    `status`         TINYINT      NOT NULL DEFAULT &#x27;0&#x27; COMMENT &#x27;0:locked ,1:rollbacking&#x27;,    `gmt_create`     DATETIME,    `gmt_modified`   DATETIME,    PRIMARY KEY (`row_key`),    KEY `idx_status` (`status`),    KEY `idx_branch_id` (`branch_id`),    KEY `idx_xid_and_branch_id` (`xid` , `branch_id`)) ENGINE = InnoDB  DEFAULT CHARSET = utf8mb4;CREATE TABLE IF NOT EXISTS `distributed_lock`(    `lock_key`       CHAR(20) NOT NULL,    `lock_value`     VARCHAR(20) NOT NULL,    `expire`         BIGINT,    primary key (`lock_key`)) ENGINE = InnoDB  DEFAULT CHARSET = utf8mb4;INSERT INTO `distributed_lock` (lock_key, lock_value, expire) VALUES (&#x27;AsyncCommitting&#x27;, &#x27; &#x27;, 0);INSERT INTO `distributed_lock` (lock_key, lock_value, expire) VALUES (&#x27;RetryCommitting&#x27;, &#x27; &#x27;, 0);INSERT INTO `distributed_lock` (lock_key, lock_value, expire) VALUES (&#x27;RetryRollbacking&#x27;, &#x27; &#x27;, 0);INSERT INTO `distributed_lock` (lock_key, lock_value, expire) VALUES (&#x27;TxTimeoutCheck&#x27;, &#x27; &#x27;, 0);\n\n\n准备配置文件\n\n  点此下载配置文件\n下载文件后，修改配置文件中的 mysql 连接信息和 nacos 信息，然后将整个文件夹上传到服务器的 home 目录。\n\n\nDocker 部署\n\ndocker run --name seata \\-p 8099:8099 \\-p 7099:7099 \\-e SEATA_IP=192.168.192.101 \\-v ./seata:/seata-server/resources \\--privileged=true \\--ulimit nofile=65536:65536 \\-d \\seataio/seata-server:1.5.2\n\n微服务中集成 RM\n\n导入依赖\n\n&lt;!--seata--&gt; &lt;dependency&gt;     &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt;     &lt;artifactId&gt;spring-cloud-starter-alibaba-seata&lt;/artifactId&gt; &lt;/dependency&gt;\n\n\n编写配置\n 在 nacos 中添加共享的配置 shared-seata.yaml，随后在各微服务配置拉取此配置文件\n\n\nseata:  registry: # TC服务注册中心的配置，微服务根据这些信息去注册中心获取tc服务地址    type: nacos # 注册中心类型 nacos    nacos:      server-addr: 192.168.150.101:8848 # nacos地址      namespace: &quot;&quot; # namespace，默认为空      group: DEFAULT_GROUP # 分组，默认是DEFAULT_GROUP      application: seata-server # seata服务名称      username: nacos      password: nacos  tx-service-group: hmall # 事务组名称  service:    vgroup-mapping: # 事务组与tc集群的映射关系      hmall: &quot;default&quot;  # data-source-proxy-mode: XA   # 默认为 AT模式\n\n\n使用 AT 模式必须要添加数据库表\n\n-- for AT mode you must to init this sql for you business database. the seata server not need it.CREATE TABLE IF NOT EXISTS `undo_log`(    `branch_id`     BIGINT       NOT NULL COMMENT &#x27;branch transaction id&#x27;,    `xid`           VARCHAR(128) NOT NULL COMMENT &#x27;global transaction id&#x27;,    `context`       VARCHAR(128) NOT NULL COMMENT &#x27;undo_log context,such as serialization&#x27;,    `rollback_info` LONGBLOB     NOT NULL COMMENT &#x27;rollback info&#x27;,    `log_status`    INT(11)      NOT NULL COMMENT &#x27;0:normal status,1:defense status&#x27;,    `log_created`   DATETIME(6)  NOT NULL COMMENT &#x27;create datetime&#x27;,    `log_modified`  DATETIME(6)  NOT NULL COMMENT &#x27;modify datetime&#x27;,    UNIQUE KEY `ux_undo_log` (`xid`, `branch_id`)) ENGINE = InnoDB  AUTO_INCREMENT = 1  DEFAULT CHARSET = utf8mb4 COMMENT =&#x27;AT transaction mode undo table&#x27;;\n\n微服务中集成 TM\n使用 @GlobalTransactional 标注事务即可集成 TM\n","categories":["微服务"]},{"title":"基于哈希表的简单联系人查询系统","url":"/2021/10/4704f1867b79.html","content":"\n基于散列表数据结构，采用二次再散列的方法解决冲突，编写的联系人存储系统\n\nHashTable#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#define MAXSIZE 20#define OK 1#define FALSE 0//定义存储个人信息的结构体 typedef struct&#123;\tchar name[20];\t//姓名 \tchar phone[20];\t//电话 \tchar location[30];\t//地址 &#125;Person;//定义散列表HashTabletypedef struct&#123;\tPerson* array[MAXSIZE];\t//存储联系人的动态数组 \tint count;\t\t//当前表中元素总个数 &#125;HashTable; //将电话号码处理为key int GetKey(char phone[])&#123;\t//将电话号码的每一位数字加起来即为key\tint key=0;\tint i=0;\twhile(phone[i] != &#x27;\\0&#x27;) &#123;\t\tkey += phone[i]-&#x27;0&#x27;;\t\ti++;\t&#125;//\tprintf(&quot;key = %d\\n&quot;,key);\treturn key;&#125; //散列函数 传入key返回存储的位置l=Hash(key) int Hash(int key)&#123;\treturn key%19;\t//采用除留余数法,由于表长为20,除数一般为小于或等于表长的最大质数，所以这里为19 &#125; //初始化散列表HashTable* InitHashTable()&#123;\tHashTable *hashTable = NULL;\thashTable = (HashTable*)malloc(sizeof(HashTable));\thashTable-&gt;count = 0;\t//初始化时hash表中没有元素 \tint i;\tfor(i=0;i&lt;MAXSIZE;i++)&#123;\t\thashTable-&gt;array[i] = NULL; //为每个位置的电话初始化为-1\t&#125;&#125; //int Save()//int HandleCollision(HashTable *hashTable,Person person,int loc)&#123;//\t//&#125;//插入数据int Insert(HashTable *hashTable,Person *person)&#123;\tint key = GetKey(person-&gt;phone);\tint loc = Hash(key);//获取在hash表中的位置\t \tif(hashTable-&gt;array[loc] == NULL)&#123;\t\t//如果该位置为空，就将联系人存储到此处\t\thashTable-&gt;array[loc] =  person;\t\thashTable-&gt;count++;\t\treturn OK;\t&#125;else&#123;\t\t//如果该位置不为空，则出现散列表冲突，采用二次探测再散列方式处理\t\tint j=1;\t\tint k=0;\t\twhile(1)&#123;\t\t\tint newLoc = -1;\t\t\tif(k%2 == 0)&#123;\t\t\t\tnewLoc = loc + j*j;\t\t\t\tk++;\t\t\t&#125;else&#123;\t\t\t\tnewLoc = loc - j*j;\t\t\t\tj++;\t\t\t\tk++;\t\t\t\tif(newLoc &lt; 0)&#123;\t\t\t\t\t//相减时要考虑负数，负数无法取模 \t\t\t\t\tcontinue;\t\t\t\t&#125;\t\t\t&#125;\t\t\tif(newLoc&gt;MAXSIZE)&#123;\t\t\t\t//数组越界\t\t\t\treturn FALSE; \t\t\t&#125;\t\t\tif(hashTable-&gt;array[newLoc] == NULL)&#123;\t\t\t\t//如果该位置为空，就将联系人存储到此处\t\t\t\thashTable-&gt;array[newLoc] =  person;\t\t\t\thashTable-&gt;count++;\t\t\t\treturn OK;\t\t\t&#125;\t\t&#125;\t&#125;\t&#125; //查找数据Person* Find(HashTable *hashTable,char phone[])&#123;\tint loc = Hash(GetKey(phone));//获取在hash表中的位置\tif(hashTable-&gt;array[loc] == NULL)&#123;\t\treturn NULL;\t&#125; \tif(!strcmp(hashTable-&gt;array[loc]-&gt;phone,phone))&#123;\t\t//如果该位置的值等于查询的值，就将联系人返回 \t\treturn hashTable-&gt;array[loc]; \t&#125;else&#123;\t\t//出现散列表冲突，采用二次探测再散列方式处理\t\tint j=1;\t\tint k=0;\t\twhile(1)&#123;\t\t\tint newLoc = -1;\t\t\tif(k%2 == 0)&#123;\t\t\t\tnewLoc = loc + j*j;\t\t\t\tk++;\t\t\t&#125;else&#123;\t\t\t\tnewLoc = loc - j*j;\t\t\t\tj++;\t\t\t\tk++;\t\t\t\tif(newLoc &lt; 0)&#123;\t\t\t\t\t//相减时要考虑负数，负数无法取模 \t\t\t\t\tcontinue;\t\t\t\t&#125;\t\t\t&#125;\t\t\tif(newLoc&gt;MAXSIZE || hashTable-&gt;array[newLoc] == NULL)&#123;\t\t\t\t//未找到联系人 \t\t\t\treturn NULL;\t\t\t&#125;\t\t\t\t\t\tif(!strcmp(hashTable-&gt;array[newLoc]-&gt;phone,phone))&#123;\t\t\t\t//如果该位置的值等于查询的值，就将联系人返回 \t\t\t\treturn hashTable-&gt;array[newLoc]; \t\t\t&#125;\t\t&#125;\t&#125;&#125;//展示所有联系人,由于数组写死，所以最大存储为MAXSIZE，可自行升级为动态数组 void ShowAll(HashTable *hashTable)&#123;\tif(hashTable)&#123;\t\tint i;\t\tprintf(&quot;一共有%d条记录:\\n&quot;,hashTable-&gt;count);\t\tfor(i=0;i&lt;MAXSIZE;i++)&#123;\t\t\tif(hashTable-&gt;array[i] != NULL)&#123;\t\t\t\tprintf(&quot;姓名：%s\\t电话：%s\\t地址：%s\\t\\n&quot;,hashTable-&gt;array[i]-&gt;name,hashTable-&gt;array[i]-&gt;phone,hashTable-&gt;array[i]-&gt;location);\t\t\t&#125;\t\t&#125;\t\tprintf(&quot;加载完毕！&quot;);\t\tsystem(&quot;pause&quot;);\t&#125;else&#123;\t\tprintf(&quot;请先建立联系簙！&quot;);\t\tsystem(&quot;pause&quot;); \t&#125;&#125;void menu()&#123;    printf(&quot;\\n请选择操作&quot;);  printf(&quot;\\n========================================&quot;);  printf(&quot;\\n|          1--建立联系簙               |&quot;);  printf(&quot;\\n|          2--添加联系人               |&quot;);  printf(&quot;\\n|          3--查找联系人               |&quot;);  printf(&quot;\\n|          4--显示所以联系人           |&quot;);  printf(&quot;\\n|          0--退出                     |&quot;);  printf(&quot;\\n========================================&quot;);  printf(&quot;\\n请输入菜单号(0-4)：&quot;);&#125; void main()&#123;\tHashTable *hashTable = NULL;\twhile(1)&#123; \t\tmenu(); \t\tint i; \t\tscanf(&quot;%d&quot;,&amp;i);\t\tif(i == 1)&#123;\t\t\thashTable = InitHashTable();\t\t\tprintf(&quot;建立成功！&quot;);\t\t\tsystem(&quot;pause&quot;);\t\t&#125;else if(i == 2)&#123;\t\t\tif(hashTable == NULL)&#123;\t\t\t\tprintf(&quot;请先建立联系簙！&quot;);\t\t\t\tsystem(&quot;pause&quot;); \t\t\t\tcontinue;\t\t\t&#125;\t\t\tPerson *p = NULL;\t\t\tp = (Person*)malloc(sizeof(Person));\t\t\tprintf(&quot;输入电话号码：&quot;); \t\t\tscanf(&quot;%s&quot;,p-&gt;phone);\t\t\tprintf(&quot;输入姓名：&quot;);\t\t\tscanf(&quot;%s&quot;,p-&gt;name);\t\t\tprintf(&quot;输入地址：&quot;);\t\t\tscanf(&quot;%s&quot;,p-&gt;location);\t\t\t\t\t\tInsert(hashTable,p);\t\t\tprintf(&quot;添加成功!\\n&quot;);\t\t\tprintf(&quot;姓名：%s\\t电话：%s\\t地址：%s\\t\\n&quot;,p-&gt;name,p-&gt;phone,p-&gt;location);\t\t\tsystem(&quot;pause&quot;); \t\t&#125; else if(i == 3)&#123;\t\t\tif(hashTable == NULL)&#123;\t\t\t\tprintf(&quot;请先建立联系簙！&quot;);\t\t\t\tsystem(&quot;pause&quot;); \t\t\t\tcontinue;\t\t\t&#125;\t\t\tchar phone[20];\t\t\tprintf(&quot;输入待查找号码：&quot;);\t\t\tscanf(&quot;%s&quot;,phone); \t\t\tPerson *findPerson = Find(hashTable,phone); \t\t\tif(findPerson)&#123;\t\t\t\tprintf(&quot;查询成功:\\n&quot;); \t\t\t\tprintf(&quot;姓名：%s\\t电话：%s\\t地址：%s\\t\\n&quot;,findPerson-&gt;name,findPerson-&gt;phone,findPerson-&gt;location);\t\t\t\tsystem(&quot;pause&quot;);\t\t\t&#125;else&#123;\t\t\t\tprintf(&quot;未查询到该联系人！&quot;);\t\t\t\tsystem(&quot;pause&quot;);\t\t\t&#125;\t\t  \t\t\t&#125;else if(i == 4)&#123;\t\t\tShowAll(hashTable);\t\t&#125;else if(i == 0)&#123; \t\t  \tprintf(&quot;成功退出系统！&quot;); \t\t  \tbreak; \t\t&#125; else&#123;\t\t   printf(&quot;指令错误！&quot;);\t\t   system(&quot;pause&quot;);\t\t&#125;\t&#125;\treturn;&#125;\n","categories":["数据结构与算法"],"tags":["c","数据结构与算法"]},{"title":"基于栈的进制转换实例","url":"/2021/10/705121821ad6.html","content":"\n一个进制转换的小程序，利用栈数据结构的特性\n\n#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#define MAXSIZE 200typedef struct&#123;\t//这里采用不同于算法总结帖子里的方法建立栈 \tint *top;  //指向栈顶 \tint *base; //指向栈底 \tint SIZE;&#125;Stack;Stack *initStack()&#123;\tStack *s = (Stack*)malloc(sizeof(Stack));\t//动态声明一个栈 \ts-&gt;SIZE = MAXSIZE;\t\t\t\t\t\t\t//设置栈的最大大小 \ts-&gt;base = (int*)malloc(MAXSIZE*sizeof(int));//动态生成一个数组将数组首地址赋值给s-&gt;base,数组大小为MAXSIZE \ts-&gt;top = s-&gt;base;\t\t\t\t\t\t\t//初始化栈时栈为空，所以栈顶指针与栈底指针指向数组首地址 \treturn s;&#125;//判断栈是否为空，当栈顶与栈底指向同一块区域则表明栈为空 int isEmpty(Stack *s)&#123;\tif(s-&gt;base == s-&gt;top) return 1;\treturn 0;&#125;//判断栈是否满，如果栈顶-栈底等于栈的最大长度则满 int isFull(Stack *s)&#123;\tif(s-&gt;top - s-&gt;base == s-&gt;SIZE) return 1;\treturn 0;&#125;//压栈，先判断栈是否满，未满则将数据存入，栈顶指针++ int push(Stack *s,int data)&#123;\tif(!isFull(s))&#123;\t\t*(s-&gt;top) = data;\t\ts-&gt;top++;\t\treturn 1;\t&#125;\treturn 0;&#125;//出栈，先判断栈是否空，不为空则将数据弹出，栈顶指针-- int pop(Stack *s,int *data)&#123;\tif(!isEmpty(s))&#123;\t\t*data = *(s-&gt;top-1);\t\ts-&gt;top--;\t\treturn 1;\t&#125;\treturn 0;&#125;int main()&#123;\tprintf(&quot;请输入一位数:&quot;);\tint num;\tscanf(&quot;%d&quot;,&amp;num);\tprintf(&quot;请输入转换的进制:&quot;);\tint n;\tscanf(&quot;%d&quot;,&amp;n);\tint next = num;\tStack *s = initStack();\t\t//申请一个栈\t//利用栈先进后出的原理，将进制转换的余数依次放入栈中，最后在依次出栈，出栈顺序即为进制数 \twhile(next != 0)&#123;\t\tpush(s,next % n );\t\tnext = next / n;\t&#125;\t\t//循环出栈直到栈空 \twhile(!isEmpty(s))&#123;\t\tint data;\t\tpop(s,&amp;data);\t\tprintf(&quot;%d&quot;,data);\t&#125;\treturn 0;&#125;\n","categories":["数据结构与算法"],"tags":["c","数据结构与算法","栈"]},{"title":"数据结构与算法笔记","url":"/2021/09/0c3e8f69e82f.html","content":"\n准备把常用的数据结构与算法都手撸一遍，程序都经过调试并且可运行，代码中也有过程注释便于理解。之后会把各种数据结构的应用补上，比如基于栈的二进制转换，计算器，基于链表的一元多项式求和等。\n\n数据结构顺序表#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#define MAXLEN 100typedef int DataType;\t//定义数据类型 //用结构体来完成顺序表 typedef struct&#123;\t//DataType data[MAXLEN];\t//存储顺序表数据的数组 \tDataType *data;\t\t\t\t//采用动态初始化数组的方法 \tint length;\t\t\t\t\t//顺序表的长度 &#125;SeqList;// 对顺序表操作的一些函数//1.初始化顺序表操作 void initSeqList(SeqList *seqList)&#123;\tseqList-&gt;data=(DataType*)malloc(sizeof(DataType)*MAXLEN);//数组动态初始化 \tseqList-&gt;length = 0;\t//初始化一个空的顺序表，顺序表长度为0 &#125;//2.建立顺序表,n为建立顺序表的元素数目 void createSeqList(SeqList *seqList,int n)&#123;\tif(n&gt;MAXLEN)&#123;\t\tprintf(&quot;超过最大存储长度！\\n&quot;);\t\treturn;\t&#125;\tif(n&lt;1)&#123;\t\tprintf(&quot;未添加元素！\\n&quot;);\t\treturn;\t&#125;\t\t\tprintf(&quot;请输入%d个元素：&quot;,n);\tint i;\tfor(i=0;i&lt;n;i++)&#123;\t\tscanf(&quot;%d&quot;,&amp;seqList-&gt;data[i]);\t&#125; \tseqList-&gt;length=i;\tgetchar();&#125;//3.查取顺序表中第几位的内容 ,i为位置，returnData是返回的数据 int getItemByLocation(SeqList *seqList,int index,DataType *returnData)&#123;\tif(index &gt; seqList-&gt;length || index&lt;1)&#123;\t\treturn 0;\t\t&#125;else&#123;\t\t*returnData = seqList-&gt;data[index-1];\t\treturn 1;\t\t&#125; &#125; //4.根据内容查询其在顺序表中的位置int getItemByContent(SeqList *seqList,DataType context) &#123;\tint i;\tfor(i=0;i&lt;seqList-&gt;length;i++)&#123;\t\tif(seqList-&gt;data[i] == context)&#123;\t\t\treturn i+1;\t\t&#125;\t&#125;\treturn 0;&#125;//5.插入操作int insertItem(SeqList *seqList,DataType context,int i)&#123;\tif(seqList-&gt;length &gt;= MAXLEN || i&lt;1 || i&gt;seqList-&gt;length+1)&#123;\t\t//当前顺序表长度已经满了或者i的值非法\t\tprintf(&quot;操作错误！&quot;);\t\treturn 0; \t&#125;\tif(i == seqList-&gt;length+1)&#123;\t\t//插入的位置为最后一个位置则直接放入 \t\tseqList-&gt;data[i-1] = context; \t&#125;\tint j;\tfor(j = seqList-&gt;length-1;j&gt;=i-1;j--)&#123;\t\tseqList-&gt;data[j+1] = seqList-&gt;data[j];\t//元素后移 \t&#125;\tseqList-&gt;data[i-1] = context;//插入新元素 \tseqList-&gt;length++;\treturn 1;&#125; //6.删除操作int  deleteItem(SeqList *seqList,int i,DataType *returnData)&#123;\tif(seqList-&gt;length == 0)&#123;\t\t//表为空则无法删除 \t\tprintf(&quot;顺序表为空&quot;);\t\treturn 0;\t&#125;\tif(i&gt;seqList-&gt;length||i&lt;1)&#123;\t\tprintf(&quot;超出范围&quot;);\t\treturn 0;\t&#125;\t*returnData = seqList-&gt;data[i-1];//删除元素 \tint j;\tfor(j=i;j&lt;seqList-&gt;length;j++)&#123;\t\t//元素前移 \t\tseqList-&gt;data[j-1] = seqList-&gt;data[j];\t&#125;\tseqList-&gt;length--; //长度减一\treturn 1; &#125; //7.显示顺序表中的所有数据 void showAll(SeqList *seqList)&#123;\tint i;\tfor(i=0;i&lt;seqList-&gt;length;i++)&#123;\t\tprintf(&quot;%d  &quot;,seqList-&gt;data[i]);\t&#125;&#125;//8.菜单显示void menu()&#123;    printf(&quot;\\n顺序表的各种操作&quot;);  printf(&quot;\\n========================================&quot;);  printf(&quot;\\n|          1--建立顺序表               |&quot;);  printf(&quot;\\n|          2--插入元素                 |&quot;);  printf(&quot;\\n|          3--删除元素                 |&quot;);  printf(&quot;\\n|          4--按位置查找元素           |&quot;);  printf(&quot;\\n|          5--按元素值查找其在表中位置 |&quot;);  printf(&quot;\\n|          6--求顺序表的长度           |&quot;);  printf(&quot;\\n|          7--显示顺序表内容           |&quot;);  printf(&quot;\\n|          8--销毁顺序表               |&quot;);  printf(&quot;\\n|          0--返回                     |&quot;);  printf(&quot;\\n========================================&quot;);  printf(&quot;\\n请输入菜单号(0-8)：&quot;);&#125; //9.补充操作//9.1销毁 void destroySeqList(SeqList *seqList)&#123;\tif(seqList-&gt;data)&#123;\t\tfree(seqList-&gt;data);\t\tseqList-&gt;length=0;\t&#125;&#125;//9.2main()&#123;\tSeqList seqList; \tDataType dataType;\tint context;\tint n,i,loc,x;\tchar ch1,ch2,a;\tch1=&#x27;y&#x27;;\twhile(ch1==&#x27;y&#x27;||ch1==&#x27;Y&#x27;)&#123;\t\tmenu();\t\tscanf(&quot;%c&quot;,&amp;ch2);\t\tgetchar();\t\tswitch(ch2)\t\t&#123;\t\t\tcase &#x27;1&#x27;:\t\t\t\tinitSeqList(&amp;seqList);\t\t\t\tprintf(&quot;请输入建立线性表的个数：&quot;);\t\t\t\tscanf(&quot;%d&quot;,&amp;n);\t\t\t\tcreateSeqList(&amp;seqList,n);\t\t\t\tprintf(&quot;建立的线性表为：&quot;);\t\t\t\tshowAll(&amp;seqList);\t\t\t\tbreak;\t  \t\tcase &#x27;2&#x27;:\t\t\t\tprintf(&quot;请输入要插入的位置：&quot;);\t\t\t\tscanf(&quot;%d&quot;,&amp;i);\t\t\t\tgetchar();\t\t\t\tprintf(&quot;请输入要插入的元素值：&quot;);\t\t\t\tscanf(&quot;%d&quot;,&amp;context);\t\t\t\tgetchar();\t\t\t\tif(insertItem(&amp;seqList,context,i))&#123;\t\t\t\t\tprintf (&quot;已成功在第%d的位置上插入%2d,插入后的线性表为: \\n&quot;,i,context);\t\t\t\t\tshowAll(&amp;seqList);\t\t\t\t\tbreak;\t\t\t\t&#125;else&#123;\t\t\t\t\tprintf(&quot;输入插入的参数错误!\\n&quot;);\t\t\t\t\tbreak;\t\t\t\t&#125;\t\t\tcase &#x27;3&#x27;:\t\t\t\tprintf(&quot;请输入要删除元素的位置: &quot;);\t\t\t\tscanf(&quot;%d&quot;,&amp;i);\t\t\t\tif(deleteItem(&amp;seqList,i,&amp;x))&#123;\t\t\t\t\tprintf (&quot;已成功在第%d的位置上删除%d,删除后的线性表为: \\n&quot;,i,x);\t\t\t\t\tshowAll(&amp;seqList);\t\t\t\t&#125;else\t\t\t\t\tprintf (&quot;\\n输入删除的参数错误!&quot;);\t\t\t\tbreak;\t\t\tcase &#x27;4&#x27;:\t\t\t\tprintf(&quot;请输入要查看表中元素位置(从1开始): &quot;);\t\t\t\tscanf (&quot;%d&quot;,&amp;i);\t\t\t\tif (getItemByLocation(&amp;seqList,i, &amp;x))\t\t\t\t\tprintf(&quot;当前线性表第%d个元素的值为: %d&quot;,i,x);\t\t\t\telse\t\t\t\t\tprintf (&quot;输入的位置错误!&quot;);\t\t\t\tbreak;\t\t\tcase &#x27;5&#x27;:\t\t\t\tprintf(&quot;请输入要查找的元素值为: &quot;) ;\t\t\t\tscanf(&quot;%d&quot;,&amp;context) ;\t\t\t\tloc = getItemByContent(&amp;seqList, context);\t\t\t\tif(loc)\t\t\t\t\tprintf(&quot;查找元素值为%d的位置为: %d&quot;,context, loc);\t\t\t\telse\t\t\t\t\tprintf (&quot;该表中无此元素!&quot;);\t\t\t\tbreak;\t\t\tcase &#x27;6&#x27;:\t\t\t\tprintf(&quot;当前线性表的长度为: %d&quot;,seqList.length);\t\t\t\tbreak;\t\t\tcase &#x27;7&#x27;:\t\t\t\tshowAll(&amp;seqList); \t\t\t\tbreak;\t\t\tcase &#x27;8&#x27;:\t\t\t\tdestroySeqList(&amp;seqList);\t\t\t\tbreak;\t\t\tcase &#x27;0&#x27; :\t\t\t\tch1=&#x27;n&#x27;;\t\t\t\tbreak;\t\t\tdefault:\t\t\t\tprintf(&quot;输入有误，请输入0~6进行选择!&quot;);\t\t\t&#125;\t\tprintf(&quot;\\n&quot;);\t\t\tsystem(&quot;pause&quot;);\t\t\t&#125;&#125;\n\n单链表\n结构体版本链表-动态链表，由于每次插入需要动态分配空间，效率太低，适合工程开发时使用\n\n数组模拟链表-静态链表，速度快，适合于算法题\n动态链表#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;typedef int DataType;typedef struct linknode&#123;\tDataType data;\tstruct linknode *next;&#125; LinkList;//初始化一个单链表void *initList()&#123;\tLinkList *head;\thead = (LinkList*)malloc(sizeof(LinkList));\t//动态的分配一个头指针 \thead-&gt;next= NULL;\treturn head;&#125; //增-头插法,n插入的元素 void createListH(LinkList *head,int n)&#123;\tLinkList *node;\tint i;\tprintf(&quot;请输入%d个元素:&quot;,n);\tfor(i=0;i&lt;n;i++)&#123;\t\tnode = (LinkList*)malloc(sizeof(LinkList));\t//动态分配一个新节点 \t\tscanf(&quot;%d&quot;,&amp;node-&gt;data);\t\t\t\t//将新节点的next指针指向上一个添加的节点(头节点)\t\tnode-&gt;next = head-&gt;next; \t\t//更新头节点\t\thead-&gt;next = node; \t&#125;\tprintf(&quot;通过头插法成功建立链表！&quot;);&#125; //增-尾插法，n插入的元素 void createListL(LinkList *head,int n)&#123;\t\tLinkList *node,*last;\tlast = head;\t\t//设置头为最后一个节点 \tint i;\tprintf(&quot;请输入%d个元素：&quot;,n);\tfor(i=0;i&lt;n;i++)&#123;\t\tnode = (LinkList*)malloc(sizeof(LinkList));//动态生成新节点 \t\tscanf(&quot;%d&quot;,&amp;node-&gt;data);\t\t\t\t\t\t\tlast-&gt;next=node;\t\t\t\t\t\t\t//设置新节点为最后节点 \t\tnode-&gt;next=NULL;\t\t\t\t\t\t\t//设置最后一个节点的next为空 \t\tlast = node;\t\t\t\t\t\t\t\t//将last指向s \t&#125;\tprintf(&quot;通过尾插法成功建立链表!&quot;); &#125; //查询链表长度int lengthList(LinkList *head)&#123;\tLinkList *node;\tint count = 0;\tnode = head-&gt;next;\twhile(node!=NULL)&#123;\t\t//不为尾节点则进入循环 \t\tcount++;\t\tnode=node-&gt;next;\t&#125;\treturn count;\t&#125; //按值查数据int queryDataByContent(LinkList *head,DataType x)&#123;\tLinkList *node;\tnode = head-&gt;next;\tint j=1;\twhile(node != NULL &amp;&amp; node-&gt;data != x)&#123;\t\tnode = node-&gt;next;\t\tj++;\t&#125;\tif(node != NULL)&#123;\t\tprintf(&quot;在表的%d位找到了元素%d&quot;,j,node-&gt;data);\t\treturn j;\t&#125;else&#123;\t\tprintf(&quot;未查询到该元素&quot;);\t\treturn 0;\t&#125;&#125; //按序号查询,i为索引，data为查询到的数据为null则未查到  int queryDataByIndex(LinkList *head,int i,DataType *data)&#123; \tLinkList *node; \tint j=1; \tnode = head-&gt;next;\t if(i&lt;1 || i&gt;lengthList(head))&#123; \t\t//位置错误  \t\tprintf(&quot;位置错误!&quot;);  \t\treturn 0;\t&#125;\twhile(node!=NULL &amp;&amp; j&lt;i)&#123;\t\tnode = node-&gt;next;\t\tj++;\t&#125;\tif(j==i)&#123;\t\tprintf(&quot;第%d位元素为：%d&quot;,i,node-&gt;data);\t\tdata = &amp;node-&gt;data;\t\treturn 1;\t&#125; &#125;   //插入 int insertItem(LinkList *head,DataType data,int i)&#123; \tLinkList *node,*newNode; \tnode = head; \tif(i&lt;1 || i&gt;lengthList(head)+1)&#123; \t\t//位置错误  \t\tprintf(&quot;位置错误!&quot;);  \t\treturn 0;\t&#125;\tint j = 0; \twhile(node-&gt;next != NULL &amp;&amp; j&lt;i-1)&#123; \t\tnode = node-&gt;next; \t\tj++;\t&#125;\tif(j==i-1)&#123;\t\tnewNode = (LinkList*)malloc(sizeof(LinkList));\t\tnewNode-&gt;data = data;\t\tnewNode-&gt;next = node-&gt;next;\t\tnode-&gt;next = newNode;\t\treturn 1;\t&#125;\treturn 0; &#125;   //删除int deleteNode(LinkList *head,int i,DataType *returnData)&#123;\tLinkList *node;\tnode = head;\tint j=0;\t\tif(i&lt;1 || i&gt;lengthList(head))&#123; \t\t//位置错误  \t\tprintf(&quot;位置错误!&quot;);  \t\treturn 0;\t&#125;\t\twhile(node-&gt;next != NULL &amp;&amp; j&lt;i-1)&#123;\t\tnode = node-&gt;next;\t\tj++;\t&#125;\tif(node-&gt;next != NULL &amp;&amp; j==i-1)&#123;\t\tLinkList *deleteNode = node-&gt;next;\t\tnode-&gt;next = node-&gt;next-&gt;next;\t\t*returnData = deleteNode-&gt;data;\t\tfree(deleteNode);\t\treturn 1;\t&#125;\treturn 0;&#125;void showAll(LinkList *head)&#123;\tLinkList *node;\tnode = head-&gt;next;\twhile(node != NULL)&#123;\t\t\t\tprintf(&quot;%d&quot;,node-&gt;data);\t\t\t\tif(node-&gt;next != NULL)&#123;\t\t\tprintf(&quot;-&gt;&quot;);\t\t&#125;\t\tnode = node-&gt;next;\t&#125;\t\t\t&#125; void menu()&#123;    printf(&quot;\\n顺序表的各种操作&quot;);  printf(&quot;\\n========================================&quot;);  printf(&quot;\\n|          1--建立链表(头插法)         |&quot;);  printf(&quot;\\n|          2--建立链表(尾插法)         |&quot;);  printf(&quot;\\n|          3--插入元素                 |&quot;);  printf(&quot;\\n|          4--删除元素                 |&quot;);  printf(&quot;\\n|          5--按位置查找元素           |&quot;);  printf(&quot;\\n|          6--按元素值查找其在表中位置 |&quot;);  printf(&quot;\\n|          7--求顺序表的长度           |&quot;);  printf(&quot;\\n|          8--显示顺序表内容           |&quot;);  printf(&quot;\\n|          0--返回                     |&quot;);  printf(&quot;\\n========================================&quot;);  printf(&quot;\\n请输入菜单号(0-8)：&quot;);&#125; main()&#123;\tLinkList *head; \tDataType context,returnData;\tint n,i,loc;\tchar ch1,ch2,a;\tch1=&#x27;y&#x27;;\twhile(ch1==&#x27;y&#x27;||ch1==&#x27;Y&#x27;)&#123;\t\tmenu();\t\tscanf(&quot;%c&quot;,&amp;ch2);\t\tgetchar();\t\tswitch(ch2)\t\t&#123;\t\t\tcase &#x27;1&#x27;:\t\t\t\thead = initList();\t\t\t\tprintf(&quot;请输入建立线性表的个数：&quot;);\t\t\t\tscanf(&quot;%d&quot;,&amp;n);\t\t\t\tcreateListH(head,n);\t\t\t\tprintf(&quot;建立的线性表为：&quot;);\t\t\t\tshowAll(head);\t\t\t\tbreak;\t\t\tcase &#x27;2&#x27;:\t\t\t\thead = initList();\t\t\t\tprintf(&quot;请输入建立线性表的个数：&quot;);\t\t\t\tscanf(&quot;%d&quot;,&amp;n);\t\t\t\tcreateListL(head,n);\t\t\t\tprintf(&quot;建立的线性表为：&quot;);\t\t\t\tshowAll(head);\t\t\t\tbreak;\t  \t\tcase &#x27;3&#x27;:\t\t\t\tprintf(&quot;请输入要插入的位置：&quot;);\t\t\t\tscanf(&quot;%d&quot;,&amp;i);\t\t\t\tprintf(&quot;请输入要插入的值：&quot;);\t\t\t\tscanf(&quot;%d&quot;,&amp;context);\t\t\t\t\t\t\t\tif(insertItem(head,context,i))&#123;\t\t\t\t\tprintf (&quot;已成功在第%d的位置上插入%2d,插入后的线性表为: \\n&quot;,i,context);\t\t\t\t\tshowAll(head);\t\t\t\t\tbreak;\t\t\t\t&#125;else&#123;\t\t\t\t\tprintf(&quot;输入插入的参数错误!\\n&quot;);\t\t\t\t\tbreak;\t\t\t\t&#125;\t\t\tcase &#x27;4&#x27;:\t\t\t\tprintf(&quot;请输入要删除元素的位置: &quot;);\t\t\t\tscanf(&quot;%d&quot;,&amp;i);\t\t\t\tif(deleteNode(head,i,&amp;returnData))&#123;\t\t\t\t\tprintf (&quot;已成功在第%d的位置上删除%d,删除后的线性表为: \\n&quot;,i,returnData);\t\t\t\t\tshowAll(head);\t\t\t\t&#125;else&#123;\t\t\t\t\tprintf (&quot;\\n输入删除的参数错误!&quot;);\t\t\t\t&#125;\t\t\t\t\tbreak;\t\t\tcase &#x27;5&#x27;:\t\t\t\tprintf(&quot;请输入要查看表中元素位置(从1开始): &quot;);\t\t\t\tscanf (&quot;%d&quot;,&amp;i);\t\t\t\tif (queryDataByIndex(head,i, &amp;returnData))\t\t\t\t\tprintf(&quot;当前线性表第%d个元素的值为: %d&quot;,i,returnData);\t\t\t\telse\t\t\t\t\tprintf (&quot;输入的位置错误!&quot;);\t\t\t\tbreak;\t\t\tcase &#x27;6&#x27;:\t\t\t\tprintf(&quot;请输入要查找的元素值为: &quot;) ;\t\t\t\tscanf(&quot;%d&quot;,&amp;context) ;\t\t\t\tloc = queryDataByContent(head, context);\t\t\t\tif(loc)\t\t\t\t\tprintf(&quot;查找元素值为%d的位置为: %d&quot;,context, loc);\t\t\t\telse\t\t\t\t\tprintf (&quot;该表中无此元素!&quot;);\t\t\t\tbreak;\t\t\tcase &#x27;7&#x27;:\t\t\t\tprintf(&quot;当前线性表的长度为: %d&quot;,lengthList(head));\t\t\t\tbreak;\t\t\tcase &#x27;8&#x27;:\t\t\t\tshowAll(head); \t\t\t\tbreak;\t\t\tcase &#x27;0&#x27; :\t\t\t\tch1=&#x27;n&#x27;;\t\t\t\tbreak;\t\t\tdefault:\t\t\t\tprintf(&quot;输入有误，请输入0~6进行选择!&quot;);\t\t\t&#125;\t\t\t\t\tprintf(&quot;\\n&quot;);\t\t\tsystem(&quot;pause&quot;);\t\t\t&#125;&#125;\n\n静态链表\n参考题目：链表操作\n\n#include &lt;iostream&gt;using namespace std;const int MAX = 100005; //静态链表，最大可存储的节点大小//结构体版本链表-动态链表，由于每次插入需要动态分配空间，效率太低，适合工程开发时使用//数组模拟链表-静态链表，速度快，适合于算法题//用数组某一块空间存储内容，数组下标看作这一块空间的指针//例如：head-头指针存储第一节点的值；e[i]存储节点的值ne[i]存储该节点下一节点地址，i下标作为该节点的地址，idx表明当前已经有多少个节点int head,e[MAX],ne[MAX],idx;//初始化链表，头指针为-1，idx为0void init()&#123;    head = -1;    idx = 0;&#125;//头插法插入节点void insert_head(int v)&#123;    //idx表明现在有多少个节点，在进行插入时类似于动态链表分配空间所返回的地址    //假设：这时idx = 2,那么e[0]ne[0]是第一个节点,e[1]ne[1]是第二个节点，idx=3指向的e[3]ne[3]这时为空    //这就类比于动态链表动态赋值后所返回的节点地址    e[idx] = v;             //初始化新节点的值    ne[idx] = head;         //初始化新节点指向的下一节点地址(头插法)    head = idx;             //更新头指针指向新节点    idx++;                  //节点数加1&#125;//删除k节点后面的一个节点void delet(int k)&#123;    ne[k] = ne[ne[k]];      //将k个节点的next指针指向它的下一节点的下一节点&#125;//在k个节点后插入一个节点void insert(int k,int v)&#123;    e[idx] = v;             //首先要开辟这个节点(idx为新节点指针,前面解释过)    ne[idx] = ne[k];        //新节点的下一节点指向k节点的下一节点    ne[k] = idx;            //将k节点的下一节点更新为新节点    idx++;                  //总节点数加1&#125;int main()&#123;    int n;    cin&gt;&gt;n;    init();    while(n--)&#123;        char c;        cin&gt;&gt;c;        if(c == &#x27;H&#x27;)&#123;            int a;            cin&gt;&gt;a;            insert_head(a);        &#125;        if(c == &#x27;D&#x27;)&#123;            int k;            cin&gt;&gt;k;            if(k == 0) head = ne[head];            else delet(k-1);        &#125;        if(c == &#x27;I&#x27;)&#123;            int k,v;            cin&gt;&gt;k&gt;&gt;v;            insert(k-1,v);        &#125;    &#125;    //从头节点开始遍历，指针指向第一个节点，只要当前节点值不为-1(-1表示结束)则打印该节点值之后更新指针i指向当前节点的下一节点    for(int i = head;i != -1;i = ne[i])&#123;        printf(&quot;%d &quot;,e[i]);    &#125;    return 0;&#125;\n\n栈#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;const int MAX = 20;\t//定义栈的最大存储量 typedef int DataType;\t//定义存储的数据类型 typedef struct&#123;\tDataType data[MAX];\tint top;\t\t\t//栈顶的序号 &#125;SeqStack; //初始化栈 SeqStack *initStack()&#123;\tSeqStack *seqStack = (SeqStack*)malloc(sizeof(SeqStack));\tseqStack-&gt;top = -1;&#125;//判断栈空int emptyStack(SeqStack *seqStack)&#123;\tif(seqStack -&gt; top == -1)&#123;\t\treturn 1;\t&#125;\treturn 0;&#125;//判断栈满 int fullSeqStack(SeqStack *seqStack)&#123;\tif(seqStack-&gt;top == MAX - 1)&#123;\t\treturn 1;\t&#125;\treturn 0;&#125;//入栈int push(SeqStack *seqStack,DataType data)&#123;\t\tif(fullSeqStack(seqStack))&#123;\t\tprintf(&quot;栈满,无法添加元素&quot;);\t\treturn 0;\t&#125;\t\tseqStack-&gt;data[++seqStack-&gt;top] = data;\treturn 1;&#125;//出栈int pop(SeqStack *seqStack,DataType *data)&#123;\tif(emptyStack(seqStack))&#123;\t\tprintf(&quot;栈为空&quot;);\t\treturn 0;\t&#125;\t*data = seqStack-&gt;data[seqStack-&gt;top--];\treturn 1;&#125; //获取栈顶元素int getTop(SeqStack *seqStack,DataType *data)&#123;\tif(emptyStack(seqStack))&#123;\t\tprintf(&quot;栈为空&quot;);\t\treturn 0;\t&#125;\t*data = seqStack-&gt;data[seqStack-&gt;top];\treturn 1;&#125; void menu()&#123;    printf(&quot;\\n栈的各种操作:&quot;);  printf(&quot;\\n====================================&quot;);  printf(&quot;\\n|          1--建立栈               |&quot;);  printf(&quot;\\n|          2--入栈                 |&quot;);  printf(&quot;\\n|          3--出栈                 |&quot;);  printf(&quot;\\n|          4--获取栈顶             |&quot;);  printf(&quot;\\n|          0--返回                 |&quot;);  printf(&quot;\\n====================================&quot;);  printf(&quot;\\n请输入菜单号(0-4)：&quot;);&#125; int main()&#123;\tchar ch1,ch2;\tch1=&#x27;y&#x27;;\tSeqStack *seqStack;\tint context;\t\twhile(ch1==&#x27;y&#x27;||ch1==&#x27;Y&#x27;)&#123;\t\tmenu();\t\tscanf(&quot;%c&quot;,&amp;ch2);\t\tgetchar();\t\tswitch(ch2)\t\t&#123;\t\t\tcase &#x27;1&#x27;:\t\t\t\tseqStack = initStack(); \t\t\t\tprintf(&quot;初始化成功!&quot;);\t\t\t\tbreak;\t  \t\tcase &#x27;2&#x27;:\t  \t\t\tif(seqStack == NULL) &#123;\t  \t\t\t\tprintf(&quot;请先初始化！\\n&quot;);\t  \t\t\t\tbreak; \t\t\t\t  &#125;\t\t\t\tprintf(&quot;请输入入栈元素:&quot;);\t\t\t\tscanf(&quot;%d&quot;,&amp;context);\t\t\t\tgetchar();\t\t\t\tif(push(seqStack,context))\t\t\t\t\tprintf(&quot;入栈成功\\n&quot;);\t\t\t\tbreak;\t\t\tcase &#x27;3&#x27;:\t\t\t\tif(pop(seqStack,&amp;context))&#123;\t\t\t\t\tprintf (&quot;%d出栈成功 \\n&quot;,context);\t\t\t\t&#125;\t\t\t\tbreak;\t\t\tcase &#x27;4&#x27;:\t\t\t\tif(getTop(seqStack,&amp;context))&#123;\t\t\t\t\tprintf (&quot;栈顶元素为%d \\n&quot;,context);\t\t\t\t&#125;\t\t\t\tbreak; \t\t\tcase &#x27;0&#x27; :\t\t\t\tch1=&#x27;n&#x27;;\t\t\t\tbreak;\t\t\tdefault:\t\t\t\tprintf(&quot;输入有误，请输入0~6进行选择!&quot;);\t\t\t&#125;\t\t\t\t\tprintf(&quot;\\n&quot;);\t\t\tsystem(&quot;pause&quot;);\t&#125;\treturn 0;&#125;\n\n队列#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt; #define MAX 5using namespace std;typedef int DataType;typedef struct&#123;\tDataType *base;\t//base数组，之后动态赋值 \tint front;\t\t//队头 \tint rear;\t\t//队尾 &#125;SqQueue;//初始化队列 SqQueue *initQueue()&#123;\t\tSqQueue *queue = (SqQueue*)malloc(sizeof(SqQueue));\t\tqueue-&gt;base = (DataType*)malloc(MAX*sizeof(SqQueue));\t//动态声明数组空间 \tqueue-&gt;front = 0;\t\t\t\t//初始化时对头与对尾指向同一位置 \tqueue-&gt;rear = 0;&#125;//判断队列是否为空 int isEmpty(SqQueue *queue)&#123;\t//如果队头与队尾相同则表明为空 \tif(queue-&gt;front == queue-&gt;rear) return 1;\treturn 0;&#125;//判断队列是否满 int isFull(SqQueue *queue)&#123;\t//牺牲一个空间不存储，用于判断队满 \tif((queue-&gt;rear+1)%MAX == queue-&gt;front) return 1;\treturn 0;&#125;//入队操作 int push(SqQueue *queue,DataType data)&#123;\t//先判断是否队满 \tif(!isFull(queue))&#123;\t\tqueue-&gt;base[queue-&gt;rear] = data;\t\tqueue-&gt;rear = (queue-&gt;rear+1)%MAX;\t//更新尾指针，通过取模运算来构建循环队列，解决假溢出情况 \t\treturn 1;\t&#125;\treturn 0; &#125;//出队操作 int pop(SqQueue *queue,DataType *data)&#123;\t//先判断是否队空 \tif(!isEmpty(queue))&#123;\t\t*data = queue-&gt;base[queue-&gt;front];\t\tqueue-&gt;front = (queue-&gt;front+1)%MAX;//更新头指针，通过取模运算来构建循环队列，解决假溢出情况\t\treturn 1;\t&#125;\treturn 0; &#125;//返回队首元素 int front(SqQueue *queue,DataType *data)&#123;\t//先判断是否队空 \tif(!isEmpty(queue))&#123;\t\t*data = queue-&gt;base[queue-&gt;front];\t\treturn 1;\t&#125;\treturn 0; &#125;//返回队尾元素 int rear(SqQueue *queue,DataType *data)&#123;\t//先判断是否队空 \tif(!isEmpty(queue))&#123;\t\t*data = queue-&gt;base[(queue-&gt;rear-1&lt;0?MAX-1:queue-&gt;rear-1)];\t//特殊判断一下当尾指针在下标0的情况 \t\treturn 1;\t&#125;\treturn 0; &#125;//获取栈的长度int getLength(SqQueue *queue) &#123;\treturn (queue-&gt;rear-queue-&gt;front+MAX)%MAX;&#125;void menu()&#123;    printf(&quot;\\n队列的各种操作:&quot;);  printf(&quot;\\n====================================&quot;);  printf(&quot;\\n|          1--建立队列             |&quot;);  printf(&quot;\\n|          2--入队                 |&quot;);  printf(&quot;\\n|          3--出队                 |&quot;);  printf(&quot;\\n|          4--获取队首元素         |&quot;);  printf(&quot;\\n|          5--获取队尾元素         |&quot;);   printf(&quot;\\n|          6--获取队长度           |&quot;);   printf(&quot;\\n|          0--返回                 |&quot;);  printf(&quot;\\n====================================&quot;);  printf(&quot;\\n请输入菜单号(0-6)：&quot;);&#125; int main()&#123;\tchar ch1,ch2;\tch1=&#x27;y&#x27;;\tSqQueue *queue = NULL; \tDataType context;\t\twhile(ch1==&#x27;y&#x27;||ch1==&#x27;Y&#x27;)&#123;\t\tmenu();\t\tscanf(&quot;%c&quot;,&amp;ch2);\t\tgetchar();\t\tswitch(ch2)\t\t&#123;\t\t\tcase &#x27;1&#x27;:\t\t\t\tqueue = initQueue(); \t\t\t\tprintf(&quot;初始化成功!&quot;);\t\t\t\tbreak;\t  \t\tcase &#x27;2&#x27;:\t  \t\t\t//如果未初始化就不继续执行 \t  \t\t\tif(queue == NULL) &#123;\t  \t\t\t\tprintf(&quot;请先初始化！\\n&quot;);\t  \t\t\t\tbreak; \t\t\t\t&#125;\t\t\t\tprintf(&quot;请输入入队元素:&quot;);\t\t\t\tscanf(&quot;%d&quot;,&amp;context);\t\t\t\tgetchar();\t\t\t\tif(push(queue,context))\t\t\t\t\tprintf(&quot;入队成功\\n&quot;);\t\t\t\telse \t\t\t\t\tprintf(&quot;队满&quot;); \t\t\t\tbreak;\t\t\tcase &#x27;3&#x27;:\t\t\t\tif(pop(queue,&amp;context))&#123;\t\t\t\t\tprintf (&quot;%d出队成功 \\n&quot;,context);\t\t\t\t&#125;else \t\t\t\t\tprintf(&quot;队空&quot;);\t\t\t\tbreak;\t\t\tcase &#x27;4&#x27;:\t\t\t\tif(front(queue,&amp;context))&#123;\t\t\t\t\tprintf (&quot;队首元素为%d \\n&quot;,context);\t\t\t\t&#125;else \t\t\t\t\tprintf(&quot;队空&quot;);\t\t\t\tbreak; \t\t\tcase &#x27;5&#x27;:\t\t\t\tif(rear(queue,&amp;context))&#123;\t\t\t\t\tprintf (&quot;队尾元素为%d \\n&quot;,context);\t\t\t\t&#125; else \t\t\t\t\tprintf(&quot;队空&quot;);\t\t\t\t\tbreak;\t\t\tcase &#x27;6&#x27;:\t\t\t\tprintf (&quot;队长为%d \\n&quot;,getLength(queue));\t\t\t\tbreak; \t\t\tcase &#x27;0&#x27; :\t\t\t\tch1=&#x27;n&#x27;;\t\t\t\tbreak;\t\t\tdefault:\t\t\t\tprintf(&quot;输入有误，请输入0~6进行选择!&quot;);\t\t\t&#125;\t\t\t\t\tprintf(&quot;\\n&quot;);\t\t\tsystem(&quot;pause&quot;);\t&#125;\treturn 0;&#125;\n\nHashTable#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#define MAXSIZE 20#define OK 1#define FALSE 0//定义存储个人信息的结构体 typedef struct&#123;\tchar name[20];\t//姓名 \tchar phone[20];\t//电话 \tchar location[30];\t//地址 &#125;Person;//定义散列表HashTabletypedef struct&#123;\tPerson* array[MAXSIZE];\t//存储联系人的动态数组 \tint count;\t\t//当前表中元素总个数 &#125;HashTable; //将电话号码处理为key int GetKey(char phone[])&#123;\t//将电话号码的每一位数字加起来即为key\tint key=0;\tint i=0;\twhile(phone[i] != &#x27;\\0&#x27;) &#123;\t\tkey += phone[i]-&#x27;0&#x27;;\t\ti++;\t&#125;//\tprintf(&quot;key = %d\\n&quot;,key);\treturn key;&#125; //散列函数 传入key返回存储的位置l=Hash(key) int Hash(int key)&#123;\treturn key%19;\t//采用除留余数法,由于表长为20,除数一般为小于或等于表长的最大质数，所以这里为19 &#125; //初始化散列表HashTable* InitHashTable()&#123;\tHashTable *hashTable = NULL;\thashTable = (HashTable*)malloc(sizeof(HashTable));\thashTable-&gt;count = 0;\t//初始化时hash表中没有元素 \tint i;\tfor(i=0;i&lt;MAXSIZE;i++)&#123;\t\thashTable-&gt;array[i] = NULL; //为每个位置的电话初始化为-1\t&#125;&#125; //int Save()//int HandleCollision(HashTable *hashTable,Person person,int loc)&#123;//\t//&#125;//插入数据int Insert(HashTable *hashTable,Person *person)&#123;\tint key = GetKey(person-&gt;phone);\tint loc = Hash(key);//获取在hash表中的位置\t \tif(hashTable-&gt;array[loc] == NULL)&#123;\t\t//如果该位置为空，就将联系人存储到此处\t\thashTable-&gt;array[loc] =  person;\t\thashTable-&gt;count++;\t\treturn OK;\t&#125;else&#123;\t\t//如果该位置不为空，则出现散列表冲突，采用二次探测再散列方式处理\t\tint j=1;\t\tint k=0;\t\twhile(1)&#123;\t\t\tint newLoc = -1;\t\t\tif(k%2 == 0)&#123;\t\t\t\tnewLoc = loc + j*j;\t\t\t\tk++;\t\t\t&#125;else&#123;\t\t\t\tnewLoc = loc - j*j;\t\t\t\tj++;\t\t\t\tk++;\t\t\t\tif(newLoc &lt; 0)&#123;\t\t\t\t\t//相减时要考虑负数，负数无法取模 \t\t\t\t\tcontinue;\t\t\t\t&#125;\t\t\t&#125;\t\t\tif(newLoc&gt;MAXSIZE)&#123;\t\t\t\t//数组越界\t\t\t\treturn FALSE; \t\t\t&#125;\t\t\tif(hashTable-&gt;array[newLoc] == NULL)&#123;\t\t\t\t//如果该位置为空，就将联系人存储到此处\t\t\t\thashTable-&gt;array[newLoc] =  person;\t\t\t\thashTable-&gt;count++;\t\t\t\treturn OK;\t\t\t&#125;\t\t&#125;\t&#125;\t&#125; //查找数据Person* Find(HashTable *hashTable,char phone[])&#123;\tint loc = Hash(GetKey(phone));//获取在hash表中的位置\tif(hashTable-&gt;array[loc] == NULL)&#123;\t\treturn NULL;\t&#125; \tif(!strcmp(hashTable-&gt;array[loc]-&gt;phone,phone))&#123;\t\t//如果该位置的值等于查询的值，就将联系人返回 \t\treturn hashTable-&gt;array[loc]; \t&#125;else&#123;\t\t//出现散列表冲突，采用二次探测再散列方式处理\t\tint j=1;\t\tint k=0;\t\twhile(1)&#123;\t\t\tint newLoc = -1;\t\t\tif(k%2 == 0)&#123;\t\t\t\tnewLoc = loc + j*j;\t\t\t\tk++;\t\t\t&#125;else&#123;\t\t\t\tnewLoc = loc - j*j;\t\t\t\tj++;\t\t\t\tk++;\t\t\t\tif(newLoc &lt; 0)&#123;\t\t\t\t\t//相减时要考虑负数，负数无法取模 \t\t\t\t\tcontinue;\t\t\t\t&#125;\t\t\t&#125;\t\t\tif(newLoc&gt;MAXSIZE || hashTable-&gt;array[newLoc] == NULL)&#123;\t\t\t\t//未找到联系人 \t\t\t\treturn NULL;\t\t\t&#125;\t\t\t\t\t\tif(!strcmp(hashTable-&gt;array[newLoc]-&gt;phone,phone))&#123;\t\t\t\t//如果该位置的值等于查询的值，就将联系人返回 \t\t\t\treturn hashTable-&gt;array[newLoc]; \t\t\t&#125;\t\t&#125;\t&#125;&#125;//展示所有联系人,由于数组写死，所以最大存储为MAXSIZE，可自行升级为动态数组 void ShowAll(HashTable *hashTable)&#123;\tif(hashTable)&#123;\t\tint i;\t\tprintf(&quot;一共有%d条记录:\\n&quot;,hashTable-&gt;count);\t\tfor(i=0;i&lt;MAXSIZE;i++)&#123;\t\t\tif(hashTable-&gt;array[i] != NULL)&#123;\t\t\t\tprintf(&quot;姓名：%s\\t电话：%s\\t地址：%s\\t\\n&quot;,hashTable-&gt;array[i]-&gt;name,hashTable-&gt;array[i]-&gt;phone,hashTable-&gt;array[i]-&gt;location);\t\t\t&#125;\t\t&#125;\t\tprintf(&quot;加载完毕！&quot;);\t\tsystem(&quot;pause&quot;);\t&#125;else&#123;\t\tprintf(&quot;请先建立联系簙！&quot;);\t\tsystem(&quot;pause&quot;); \t&#125;&#125;void menu()&#123;    printf(&quot;\\n请选择操作&quot;);  printf(&quot;\\n========================================&quot;);  printf(&quot;\\n|          1--建立联系簙               |&quot;);  printf(&quot;\\n|          2--添加联系人               |&quot;);  printf(&quot;\\n|          3--查找联系人               |&quot;);  printf(&quot;\\n|          4--显示所以联系人           |&quot;);  printf(&quot;\\n|          0--退出                     |&quot;);  printf(&quot;\\n========================================&quot;);  printf(&quot;\\n请输入菜单号(0-4)：&quot;);&#125; void main()&#123;\tHashTable *hashTable = NULL;\twhile(1)&#123; \t\tmenu(); \t\tint i; \t\tscanf(&quot;%d&quot;,&amp;i);\t\tif(i == 1)&#123;\t\t\thashTable = InitHashTable();\t\t\tprintf(&quot;建立成功！&quot;);\t\t\tsystem(&quot;pause&quot;);\t\t&#125;else if(i == 2)&#123;\t\t\tif(hashTable == NULL)&#123;\t\t\t\tprintf(&quot;请先建立联系簙！&quot;);\t\t\t\tsystem(&quot;pause&quot;); \t\t\t\tcontinue;\t\t\t&#125;\t\t\tPerson *p = NULL;\t\t\tp = (Person*)malloc(sizeof(Person));\t\t\tprintf(&quot;输入电话号码：&quot;); \t\t\tscanf(&quot;%s&quot;,p-&gt;phone);\t\t\tprintf(&quot;输入姓名：&quot;);\t\t\tscanf(&quot;%s&quot;,p-&gt;name);\t\t\tprintf(&quot;输入地址：&quot;);\t\t\tscanf(&quot;%s&quot;,p-&gt;location);\t\t\t\t\t\tInsert(hashTable,p);\t\t\tprintf(&quot;添加成功!\\n&quot;);\t\t\tprintf(&quot;姓名：%s\\t电话：%s\\t地址：%s\\t\\n&quot;,p-&gt;name,p-&gt;phone,p-&gt;location);\t\t\tsystem(&quot;pause&quot;); \t\t&#125; else if(i == 3)&#123;\t\t\tif(hashTable == NULL)&#123;\t\t\t\tprintf(&quot;请先建立联系簙！&quot;);\t\t\t\tsystem(&quot;pause&quot;); \t\t\t\tcontinue;\t\t\t&#125;\t\t\tchar phone[20];\t\t\tprintf(&quot;输入待查找号码：&quot;);\t\t\tscanf(&quot;%s&quot;,phone); \t\t\tPerson *findPerson = Find(hashTable,phone); \t\t\tif(findPerson)&#123;\t\t\t\tprintf(&quot;查询成功:\\n&quot;); \t\t\t\tprintf(&quot;姓名：%s\\t电话：%s\\t地址：%s\\t\\n&quot;,findPerson-&gt;name,findPerson-&gt;phone,findPerson-&gt;location);\t\t\t\tsystem(&quot;pause&quot;);\t\t\t&#125;else&#123;\t\t\t\tprintf(&quot;未查询到该联系人！&quot;);\t\t\t\tsystem(&quot;pause&quot;);\t\t\t&#125;\t\t  \t\t\t&#125;else if(i == 4)&#123;\t\t\tShowAll(hashTable);\t\t&#125;else if(i == 0)&#123; \t\t  \tprintf(&quot;成功退出系统！&quot;); \t\t  \tbreak; \t\t&#125; else&#123;\t\t   printf(&quot;指令错误！&quot;);\t\t   system(&quot;pause&quot;);\t\t&#125;\t&#125;\treturn;&#125;\n\n串#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#define MAXSIZE 200typedef struct &#123;\tchar ch[MAXSIZE + 1]; //永远预留一个&#x27;\\0&#x27;的位置\tint len;\t\t\t//串的长度 &#125;String;//更新串的长度,并返回 int updateLen(String *s)&#123;\tint i = 0;\twhile(s-&gt;ch[i] != &#x27;\\0&#x27;) i++;\ts-&gt;len = i;\treturn (s-&gt;len);&#125; //创建串String* creatStr()&#123;\tString *s = (String*)malloc(sizeof(String));\tgets(s-&gt;ch);\tupdateLen(s); \treturn s;&#125; //求子串int subStr(String *s,String *sub,int index,int len)&#123;\t//判断位置和长度是否符合要求\tif(index &lt; 0 || index &gt; s-&gt;len - 1 || len &gt; s-&gt;len || len &gt; s-&gt;len - index)&#123;\t\tprintf(&quot;位置或长度错误&quot;); \t\treturn 0; //返回0则操作失败 \t&#125;\t\tfor(int i = 0; i &lt; len; i++)&#123;\t\tsub-&gt;ch[i] = s-&gt;ch[i+index];\t&#125;\tsub-&gt;ch[len] = &#x27;\\0&#x27;;\t\t//求得子串后将下一位赋值为&#x27;\\0&#x27; \tsub-&gt;len = len;\treturn 1; //操作成功 &#125; //重要操作1：删除子串int deleteStr(String *s, int index, int len)&#123;\t//判断下标和长度是否符合要求\tif(index &lt; 0 || index &gt; s-&gt;len - 1|| len &gt; s-&gt;len || len &gt; s-&gt;len - index)&#123;\t\tprintf(&quot;位置或长度错误&quot;); \t\treturn 0; //返回0则操作失败 \t&#125;\t\tfor(int i = index + len; i&lt; s-&gt;len; i++)&#123;\t\ts-&gt;ch[i-len] = s-&gt;ch[i];\t&#125;\ts-&gt;len = s-&gt;len - len;\t\t//更新串长度 \ts-&gt;ch[s-&gt;len] = &#x27;\\0&#x27;;\t\t//标上串结束字符 \treturn 1;&#125; //重要操作2：添加子串int insertStr(String *s, String *addStr,int index)&#123;\tif(index &lt; 0||index &gt; (s-&gt;len - 1))&#123;\t\tprintf(&quot;位置错误&quot;); \t\treturn 0;\t&#125;\tif(s-&gt;len + addStr-&gt;len &gt; MAXSIZE)&#123;\t\tprintf(&quot;超过最大存储长度&quot;);\t\treturn 0;\t&#125; \t\t//1.为待加入的串挪出空位\tfor(int i = s-&gt;len - 1; i&gt;= index; i--)&#123;\t\ts-&gt;ch[i+addStr-&gt;len] = s-&gt;ch[i];\t&#125;\t//2.将串加入主串 \tfor(int k = 0; k &lt; addStr-&gt;len;k++)&#123;\t\ts-&gt;ch[k+index] = addStr-&gt;ch[k];\t&#125; \t//3.更新串信息\ts-&gt;ch[s-&gt;len+addStr-&gt;len] = &#x27;\\0&#x27;;\ts-&gt;len =  s-&gt;len+addStr-&gt;len;\treturn 1;&#125; //重要操作3：从某一位置开始进行子串匹配,返回查询到的第一个子串的首字符下标，未找到返回-1 int  indexStr(String *s, String *cmpStr,int index)&#123;\tif(index &lt; 0||index &gt; (s-&gt;len - 1))&#123;\t\tprintf(&quot;位置错误&quot;); \t\treturn -1;\t&#125;\tint i = index,j = 0;\twhile(i&lt; s-&gt;len&amp;&amp; j&lt; cmpStr-&gt;len)&#123;\t\tif(s-&gt;ch[i] == cmpStr-&gt;ch[j])&#123;\t\t\ti++;\t\t\tj++;\t\t&#125;else&#123;\t\t\ti = i-j+1;\t\t\tj = 0;\t\t&#125;\t&#125;\t//查询到子串时j == cmpStr-&gt; len \tif(j&gt;= cmpStr-&gt;len)&#123;\t\treturn i-cmpStr-&gt;len;\t&#125;\t\t//未查询到 \treturn -1;&#125; //替换子串,返回成功替换的个数 int replaceStr(String *s,String *repStr,String *aimStr)&#123;\tint p = 0,count = 0;\t//串中可能包含多个待替换子串所以用循环 \tdo&#123;\t\t//1.查询待替换子串下标\t\tint index = indexStr(s,repStr,p);\t\tif(index != -1)&#123;\t\t\t//可能目标子串替换后长度超过最大长度，所以进行判断 \t\t\tif(s-&gt;len-repStr-&gt;len+aimStr-&gt;len&gt;MAXSIZE)&#123;\t\t\t\treturn count;\t\t\t&#125;\t\t\t//2.删除该子串\t\t\tdeleteStr(s,index,repStr-&gt;len);\t\t\t//3.插入目标串 \t\t\tinsertStr(s,aimStr,index);\t\t\t//4.更新p \t\t\tp = index;\t\t\tp+=aimStr-&gt;len;\t\t\t//5.更新主串长度\t\t\tcount++;\t\t&#125;\t\t//如果剩余的子串长度足够进行替换则继续进行匹配 \t&#125;while(s-&gt;len - p &gt;= aimStr-&gt;len);\treturn count; &#125;//连接两串 int catStr(String *s,String *t)&#123;\t//两串长度和小于等于最大值则可以完全连接\tif(s-&gt;len + t-&gt;len &lt;= MAXSIZE)&#123;\t\tfor(int i = 0;i&lt;t-&gt;len;i++)&#123;\t\t\ts-&gt;ch[i+s-&gt;len] = t-&gt;ch[i];\t\t&#125;\t\ts-&gt;ch[s-&gt;len+t-&gt;len] = &#x27;\\0&#x27;; //更新结束标志\t\ts-&gt;len += t-&gt;len; \t&#125; else&#123;\t\t//两串长度和大于最大值\t\tfor(int i = s-&gt;len;i&lt;MAXSIZE;i++)&#123;\t\t\ts-&gt;ch[i] = t-&gt;ch[i-s-&gt;len];\t\t&#125; \t\t\t\ts-&gt;ch[MAXSIZE] = &#x27;\\0&#x27;; //更新结束标志\t\ts-&gt;len = MAXSIZE;\t&#125;\treturn 1;&#125;//比较两串是否相等，长度不相等返回长度差，长度相等返回第一次不相等字符的ascll码差值int cmpStr(String *s,String *cmp)&#123;\tif(s-&gt;len != cmp-&gt;len)&#123;\t\treturn s-&gt;len - cmp-&gt;len;\t&#125;else&#123;\t\tint i = 0;\t\twhile(i&lt;s-&gt;len || i&lt;cmp-&gt;len)&#123;\t\t\tif(s-&gt;ch[i] != cmp-&gt;ch[i])&#123;\t\t\t\treturn s-&gt;ch[i] - cmp-&gt;ch[i];\t\t\t&#125;\t\t\ti++;\t\t&#125;\t&#125;\treturn 0;&#125; //显示串 void showStr(String *s)&#123;\tint i = 0;\twhile(s-&gt;ch[i] != &#x27;\\0&#x27;) printf(&quot;%c&quot;,s-&gt;ch[i++]);\tprintf(&quot;,串长为%d\\n&quot;,s-&gt;len);&#125;//kmp算法void getNext(String *t,int *next)&#123;\tint i = 0,k = -1;\tnext[i] = k;\twhile(i&lt;t-&gt;len)&#123;\t\tif(k == -1 || t-&gt;ch[k] == t-&gt;ch[i])&#123;\t\t\tk++;\t\t\ti++;\t\t\tnext[i] = k;\t\t&#125;else&#123;\t\t\tk = next[k];\t\t&#125;\t&#125;\tfor(int l = 0;l&lt;t-&gt;len;l++)&#123;\t\tprintf(&quot;%d &quot;,next[l]);\t&#125;&#125; int kmp(String *s,String *p,int index)&#123;\tint i = index,j = 0;\tint next[MAXSIZE];\tgetNext(p,next);\twhile(i&lt;s-&gt;len &amp;&amp; j&lt;p-&gt;len)&#123;\t\tif( j==-1 || s-&gt;ch[i] == p-&gt;ch[j])&#123;\t\t\ti++;\t\t\tj++;\t\t&#125;else&#123;\t\t\tj = next[j];\t\t&#125;\t&#125;\tif(j &gt;= p-&gt;len)&#123;\t\treturn i-p-&gt;len;\t&#125;\treturn -1;\t&#125;//菜单 void menu()&#123;    printf(&quot;\\n顺序表的各种操作&quot;);  printf(&quot;\\n========================================&quot;);  printf(&quot;\\n|          1--创建串                   |&quot;);  printf(&quot;\\n|          2--求子串                   |&quot;);  printf(&quot;\\n|          3--删除子串                 |&quot;);  printf(&quot;\\n|          4--添加子串                 |&quot;);  printf(&quot;\\n|          5--子串定位                 |&quot;);  printf(&quot;\\n|          6--替换子串                 |&quot;);  printf(&quot;\\n|          7--串的连接                 |&quot;);  printf(&quot;\\n|          8--串的比较                 |&quot;);  printf(&quot;\\n|          9--显示主串                 |&quot;);  printf(&quot;\\n|          0--返回                     |&quot;);  printf(&quot;\\n========================================&quot;);  printf(&quot;\\n请输入菜单号(0-8)：&quot;);&#125;  int main()&#123;\tchar ch1,ch2;\tString tempString;\t\t//默认空串 \ttempString.ch[0] = &#x27;\\0&#x27;;\tString *s = &amp;tempString;\tch1=&#x27;y&#x27;;\tint context;\t\twhile(ch1==&#x27;y&#x27;||ch1==&#x27;Y&#x27;)&#123;\t\tmenu();\t\tscanf(&quot;%c&quot;,&amp;ch2);\t\tgetchar();\t\tswitch(ch2)\t\t&#123;\t\t\tcase &#x27;1&#x27;:\t\t\t\t&#123;\t\t\t\t\tprintf(&quot;请输入要存储的字符串：&quot;); \t\t\t\t\ts = creatStr();\t\t\t\t\tprintf(&quot;创建字符串成功!\\n&quot;);\t\t\t\t\tshowStr(s);\t\t\t\t&#125;\t\t\t\tbreak;\t  \t\tcase &#x27;2&#x27;:\t  \t\t\t&#123;\t  \t\t\t\tprintf(&quot;主串为：&quot;);\t  \t\t\t\tshowStr(s);\t  \t\t\t\tString *sub = (String*)malloc(sizeof(String));\t\t\t\t\tprintf(&quot;\\n请输入从第几个字符求子串(下标从0开始):&quot;);\t\t\t\t\tint index;\t\t\t\t\tscanf(&quot;%d&quot;,&amp;index);\t\t\t\t\tgetchar();\t\t\t\t\tprintf(&quot;请输入求取的长度：&quot;);\t\t\t\t\tint len;\t\t\t\t\tscanf(&quot;%d&quot;,&amp;len);\t\t\t\t\tgetchar();\t  \t\t\t\tint sign = subStr(s,sub,index,len);\t  \t\t\t\tif(sign)&#123;\t  \t\t\t\t\tprintf(&quot;操作成功!,子串为：&quot;);\t\t\t\t\t\tshowStr(sub);\t\t\t\t\t\t&#125;\t  \t\t\t\t\t\t\t\t&#125;\t\t\t\tbreak;\t\t\tcase &#x27;3&#x27;:\t\t\t\t&#123;\t\t\t\t\tprintf(&quot;主串为：&quot;);\t  \t\t\t\tshowStr(s);\t\t\t\t\tprintf(&quot;\\n请输入从第几个字符删除(下标从0开始):&quot;);\t\t\t\t\tint index;\t\t\t\t\tscanf(&quot;%d&quot;,&amp;index);\t\t\t\t\tgetchar();\t\t\t\t\tprintf(&quot;请输入删除的长度：&quot;);\t\t\t\t\tint len;\t\t\t\t\tscanf(&quot;%d&quot;,&amp;len);\t\t\t\t\tgetchar();\t  \t\t\t\tint sign = deleteStr(s,index,len);\t  \t\t\t\tif(sign)&#123;\t  \t\t\t\t\tprintf(&quot;操作成功!,主串为：&quot;);\t\t\t\t\t\tshowStr(s);\t\t\t\t\t\t&#125;\t\t\t\t&#125;\t\t\t\tbreak;\t\t\t\tcase &#x27;4&#x27;:\t\t\t\t&#123;\t\t\t\t\tprintf(&quot;主串为：&quot;);\t  \t\t\t\tshowStr(s);\t  \t\t\t\tprintf(&quot;\\n请输入插入的子串:&quot;);\t  \t\t\t\tString *addStr = creatStr();\t\t\t\t\tprintf(&quot;\\n请输入插入的位置(下标从0开始):&quot;);\t\t\t\t\tint index;\t\t\t\t\tscanf(&quot;%d&quot;,&amp;index);\t\t\t\t\tgetchar();\t  \t\t\t\tint sign = insertStr(s,addStr,index);\t  \t\t\t\tif(sign)&#123;\t  \t\t\t\t\tprintf(&quot;操作成功!,主串为：&quot;);\t\t\t\t\t\tshowStr(s);\t\t\t\t\t\t&#125;\t\t\t\t&#125;\t\t\t\tbreak;\t\t\t\tcase &#x27;5&#x27;:\t\t\t\t&#123;\t\t\t\t\tprintf(&quot;主串为：&quot;);\t  \t\t\t\tshowStr(s);\t  \t\t\t\tprintf(&quot;\\n请输入要查询的子串:&quot;);\t  \t\t\t\tString *cmpStr = creatStr();\t\t\t\t\tprintf(&quot;\\n请输入从第几个字符开始查找(下标从0开始):&quot;);\t\t\t\t\tint index;\t\t\t\t\tscanf(&quot;%d&quot;,&amp;index);\t\t\t\t\tgetchar();\t  \t\t\t\t//int sign = indexStr(s,cmpStr,index);\t  \t\t\t\tint sign = kmp(s,cmpStr,index);\t  \t\t\t\tif(sign != -1)&#123;\t  \t\t\t\t\tprintf(&quot;子串在%d第一次出现.&quot;,sign);\t\t\t\t\t&#125;else&#123;\t\t\t\t\t\tprintf(&quot;未找到.&quot;);\t\t\t\t\t&#125;\t\t\t\t&#125;\t\t\t\tbreak;\t\t\t\tcase &#x27;6&#x27;:\t\t\t\t&#123;\t\t\t\t\tprintf(&quot;主串为：&quot;);\t  \t\t\t\tshowStr(s);\t  \t\t\t\tprintf(&quot;\\n请输入要替换的子串:&quot;);\t  \t\t\t\tString *repStr = creatStr();\t\t\t\t\tprintf(&quot;\\n请输入要替换为目标子串:&quot;);\t  \t\t\t\tString *aimStr = creatStr();\t  \t\t\t\tint count = replaceStr(s,repStr,aimStr);\t  \t\t\t\tprintf(&quot;替换后的主串为：&quot;); \t  \t\t\t\tshowStr(s);\t  \t\t\t\tprintf(&quot;***成功替换%d个子串***&quot;,count);\t\t\t\t&#125;\t\t\t\tbreak;\t\t\t\tcase &#x27;7&#x27;:\t\t\t\t&#123;\t\t\t\t\tprintf(&quot;主串为：&quot;);\t  \t\t\t\tshowStr(s);\t  \t\t\t\tprintf(&quot;\\n请输入要连接的串:&quot;);\t  \t\t\t\tString *str = creatStr();\t  \t\t\t\tcatStr(s,str);\t  \t\t\t\tprintf(&quot;连接后的串为：&quot;);\t  \t\t\t\tshowStr(s);\t\t\t\t&#125;\t\t\t\tbreak;\t\t\t\tcase &#x27;8&#x27;:\t\t\t\t&#123;\t\t\t\t\tprintf(&quot;主串为：&quot;);\t  \t\t\t\tshowStr(s);\t  \t\t\t\tprintf(&quot;\\n请输入要比较的子串:&quot;);\t  \t\t\t\tString *str = creatStr();\t  \t\t\t\tint sign = cmpStr(s,str);\t  \t\t\t\tif(sign == 0)&#123;\t  \t\t\t\t\tprintf(&quot;两串相等&quot;);\t\t\t\t\t&#125;else&#123;\t\t\t\t\t\tprintf(&quot;两串不相等&quot;);\t\t\t\t\t&#125;\t\t\t\t&#125;\t\t\t\tbreak;\t\t\t\tcase &#x27;9&#x27;:\t\t\t\t&#123;\t\t\t\t\tprintf(&quot;主串为：&quot;);\t  \t\t\t\tshowStr(s);\t\t\t\t&#125;\t\t\t\tbreak;\t\t\tcase &#x27;0&#x27; :\t\t\t\tch1=&#x27;n&#x27;;\t\t\t\tbreak;\t\t\tdefault:\t\t\t\tprintf(&quot;输入有误，请输入0~8进行选择!&quot;);\t\t\t&#125;\t\t\t\t&#125;\treturn 0;&#125;\n\n树二叉树#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt; //二叉树typedef struct Tree&#123;\tchar data;\tstruct Tree *lchild;\t\t//左孩子\tstruct Tree *rchild;\t\t//右孩子 &#125;BT; //递归构建二叉树(先序序列构建二叉树)//递归理解：将整个构树过程分为四步//1.构建根节点//2.构建左子树(递归建树) //3.构建右子树(递归建树) //4.返回根节点 //递归结束条件为：没有左或右孩子(输入&#x27;0&#x27;) BT *creatBT()&#123;\tBT *bt;\t//没有左或右孩子(输入&#x27;0&#x27;)，输入0则树节点为NULL \tchar ch = &#x27;0&#x27;; \tscanf(&quot;%c&quot;,&amp;ch);\tgetchar();\t//递归结束条件 \tif(ch == &#x27;0&#x27;)&#123;\t\tbt = NULL;\t&#125; else&#123;\t\t//第一步构建根节点\t\tbt = (BT*)malloc(sizeof(BT));\t\tbt-&gt;data = ch;\t\t//第二步构建左子树(递归建树) \t\tprintf(&quot;请输入%c节点的左孩子节点(无节点输入0):&quot;,bt-&gt;data); \t\tbt-&gt;lchild = creatBT();\t\t//第三步构建右子树(递归建树)  \t\tprintf(&quot;请输入%c节点的右孩子节点(无节点输入0):&quot;,bt-&gt;data); \t\tbt-&gt;rchild = creatBT();\t&#125;\t//第四步返回所创建的根节点 \treturn bt;&#125; //递归先序遍历 (先序遍历时第一个元素肯定是根节点)//递归理解：将整个遍历树过程分为三步//1.输出根节点 //2.遍历左子树(递归遍历) //3.遍历右子树(递归遍历) //递归结束条件为：没有左或右孩子void preOrderShowBT(BT *bt)&#123;\tif(bt == NULL)&#123;\t\treturn;\t&#125; \t//第一步输出根节点 \tprintf(&quot;%c &quot;,bt-&gt;data);\t//第二步遍历左子树(递归遍历)  \tpreOrderShowBT(bt-&gt;lchild); \t//第三步遍历右子树(递归遍历) \tpreOrderShowBT(bt-&gt;rchild); &#125;//递归中序遍历 //递归理解：将整个遍历树过程分为三步//1.遍历左子树(递归遍历) //2.输出根节点 //3.遍历右子树(递归遍历) //递归结束条件为：没有左或右孩子void midOrderShowBT(BT *bt)&#123;\tif(bt == NULL)&#123;\t\treturn;\t&#125; \t//第一步遍历左子树(递归遍历)\tmidOrderShowBT(bt-&gt;lchild); \t//第二步输出根节点  \tprintf(&quot;%c &quot;,bt-&gt;data);\t//第三步遍历右子树(递归遍历)\tmidOrderShowBT(bt-&gt;rchild); &#125;//递归后序遍历(后序遍历时最后一个元素肯定是根节点)//递归理解：将整个遍历树过程分为三步//1.遍历左子树(递归遍历)  //2.遍历右子树(递归遍历) //3.输出根节点//递归结束条件为：没有左或右孩子void postOrderShowBT(BT *bt)&#123;\tif(bt == NULL)&#123;\t\treturn;\t&#125; \t//第一步遍历左子树(递归遍历)\tpostOrderShowBT(bt-&gt;lchild); \t//第二步遍历右子树(递归遍历) \tpostOrderShowBT(bt-&gt;rchild); \t//第三步输出根节点\tprintf(&quot;%c &quot;,bt-&gt;data);&#125;//树的层次遍历//算法实现：需要用到一个队列(这里使用循环队列，所以对树的层数有限制)，首先把根节点加入队列中 然后循环出队，//每出队一个元素就将它的左孩子和右孩子入队，为空则不入队，直到队列为空 //如果最大可遍历树的层数为4那么数组大小应该设置为2^(k-1)+1,加一是给循环队列用于处理队满的情况 void levelOrderShowBT(BT *bt)&#123;\tconst int MAX = 9;\tBT *btQueue[MAX],*tempBt = NULL;\t\t//队列数组，临时节点 \tint front,rear;\t\t\t\t\t\t//队首指针与队尾指针\tbtQueue[0] = bt;\t\t\t\t\t//将根节点入队\tfront = 0,rear = 1;\t\t\t\t\t//更新指针\t\twhile(front != rear) &#123;\t\ttempBt = btQueue[front];\t\t//将队首出队\t\tfront = (front + 1)%MAX;\t\t\t\t\tprintf(&quot;%c &quot;,tempBt-&gt;data);\t\t\t\tif(tempBt-&gt;lchild != NULL)&#123;\t\t\tbtQueue[rear] = tempBt-&gt;lchild;\t//如果不为空则将左孩子加入队列 \t\t\trear = (rear + 1 ) % MAX;\t\t&#125;\t\tif(tempBt-&gt;rchild != NULL)&#123;\t\t\tbtQueue[rear] = tempBt-&gt;rchild;\t//如果不为空则将右孩子加入队列 \t\t\trear = (rear + 1 ) % MAX;\t\t&#125;\t\t&#125;&#125;//树的重建(前序+中序)//算法实现：(首先要知道前序遍历所得到的数组首元素肯定为待建树的根节点)//我们先判断当前待建树的节点是否为0，没有节点肯定无法建树，有节点先建立树的根节点，将前序数组的首元素存入根节点中//然后遍历中序数组，查找到该根元素(前序数组首元素)所在位置(下标i)，根据中序遍历的性质可以知道，元素左方是左子树，右方是右子树//下标i即为左子树长度，比如前序为a,b,c =中序为b,a,c.可知根元素是a，然后遍历中序数组，找到a,下标为1，左子树长度也为1.//接下来则递归建树，构建左子树(buidBT(左子树所在前序数组,左子树所在中序数组,根节点左孩子,左子树节点数))，构建右子树(buidBT(右子树所在前序数组,右子树所在中序数组,根节点右孩子右子树节点数))//总之递归算法就是三步：//1.构建根节点//2.递归构建左子树 //3.递归构建右子树//递归退出条件为待构建树长度为0 void buildBT(char *pre,char *mid,BT **bt,int len)&#123;\t//pre前序数组，mid中序数组，bt建树节点指针的指针，len待建树节点 \t//待构建树的长度为0则结束递归 \tif(len == 0)&#123;\t\t*bt = NULL;\t//没有子节点则赋值NULL \t\treturn;\t&#125;\t//第一步，构建根节点 \tint i;\t*bt = (BT*)malloc(sizeof(BT));\t//printf(&quot;%c&quot;,*pre);\t(*bt)-&gt;data=*pre;\t//*pre，pre是数组首地址，*pre即取其值类似于pre[0] \tfor(i=0;i&lt;len;i++)&#123;\t\t//在中序数组中循环遍历根的位置 \t\tif(mid[i] == *pre)&#123;\t\t\t//找到则break，这时i即为根在中序数组中的位置 \t\t\tbreak;\t\t&#125;\t&#125;\t//第二步，构建左子树 \t//pre+1，表明左子树所在先序遍历数组的首地址，他和最后一个参数i可以确定左子树的前序数组 \t//mid，左子树所在中序遍历数组的首地址，他和参数i可以确定左子树的中序数组\t//i子树长度 \tbuildBT(pre+1,mid,&amp;((*bt)-&gt;lchild),i);\t\t\t\t\t//第三步，构建右子树 \t//pre+1+i，表明右子树所在先序遍历数组的首地址，他和最后一个参数len-i-1可以确定右子树的前序数组 \t//mid+i+1，右子树所在中序遍历数组的首地址，他和参数len-i-1可以确定左子树的中序数组\t//len-i-1,子树长度\tbuildBT(pre+i+1,mid+i+1,&amp;((*bt)-&gt;rchild),len-i-1);\t\t//自行举例..... &#125; //后序加中序 void postMidBuildBT(char *post,char *mid,BT **bt,int len) &#123;\tif(len == 0)&#123;\t\t*bt = NULL;\t\treturn;\t&#125;\t\t*bt = (BT*)malloc(sizeof(BT));\t(*bt)-&gt; data = post[len-1];\tint i;\tfor(i = 0; i &lt; len; i++)&#123;\t\tif(post[len-1] == mid[i])&#123;\t\t\tbreak;\t\t&#125;\t&#125;\tpostMidBuildBT(post,mid,&amp;((*bt)-&gt;lchild),i);\tpostMidBuildBT(post+i,mid+i+1,&amp;((*bt)-&gt;rchild),len-i-1);&#125;//求节点总数int getAllNodeCount(BT *bt)&#123;\tint count = 0;\t//结束条件，左或右子树节点数量为0 \tif(bt == NULL)&#123;\t\treturn 0; \t&#125;\t//递归获取左子树的数量\tint l = getAllNodeCount(bt-&gt;lchild);\t//递归获取右子树的数量\tint r = getAllNodeCount(bt-&gt;rchild);\tcount = l+r+1;\t\t//总数为左子树数量加右子树数量加一个根节点 \treturn count;&#125;//求树深度 int getDepth(BT *bt)&#123;\t//结束条件，左或右子树节点数量为0\tif(bt == NULL)&#123;\t\treturn 0;\t&#125;\t//求左子树深度 \tint l = getDepth(bt-&gt;lchild);\t//求右子树深度 \tint r = getDepth(bt-&gt;rchild);\tint depth = 0;\t//取最大的子树深度 \tif(l &gt;= r)&#123;\t\tdepth+=l;\t&#125; else&#123;\t\tdepth+=r;\t&#125;\t//最后深度加1则为最终树的深度 \treturn ++depth;&#125; void menu()&#123;    printf(&quot;\\n树的各种操作&quot;);  printf(&quot;\\n========================================&quot;);  printf(&quot;\\n|          1--建立二叉树               |&quot;);  printf(&quot;\\n|          2--重建二叉树(前序+中序)    |&quot;);  printf(&quot;\\n|          3--重建二叉树(后序+中序)    |&quot;);  printf(&quot;\\n|          4--先序遍历                 |&quot;);  printf(&quot;\\n|          5--中序遍历                 |&quot;);  printf(&quot;\\n|          6--后序遍历                 |&quot;);  printf(&quot;\\n|          7--层次遍历                 |&quot;);  printf(&quot;\\n|          8--求树总节点数             |&quot;);  printf(&quot;\\n|          9--求树深度                 |&quot;);  printf(&quot;\\n|          0--返回                     |&quot;);  printf(&quot;\\n========================================&quot;);  printf(&quot;\\n请输入菜单号(0-9)：&quot;);&#125; int main()&#123; \tBT *bt = NULL;\tint context;\tint n,i,loc,x;\tchar ch1,ch2,a;\tch1=&#x27;y&#x27;;\twhile(ch1==&#x27;y&#x27;||ch1==&#x27;Y&#x27;)&#123;\t\tmenu();\t\tscanf(&quot;%c&quot;,&amp;ch2);\t\tgetchar();\t\tswitch(ch2)\t\t&#123;\t\t\tcase &#x27;1&#x27;:&#123;\t\t\t\tprintf(&quot;请输入根节点:&quot;);\t\t\t\tbt = creatBT(); \t\t\t\tpreOrderShowBT(bt);\t\t\t\tbreak;\t\t\t&#125;\t  \t\tcase &#x27;2&#x27;:&#123;\t  \t\t\tBT *newBt = NULL;\t  \t\t\tchar pre[100],mid[100]; \t  \t\t\tprintf(&quot;请输入先序数组：&quot;);\t\t\t\tscanf(&quot;%s&quot;,pre);\t\t\t\tgetchar();\t\t\t\tprintf(&quot;请输入中序数组：&quot;);\t\t\t\tscanf(&quot;%s&quot;,&amp;mid);\t\t\t\tgetchar();\t\t\t\tint i = 0,j = 0;\t\t\t\tfor(;pre[i]!=&#x27;\\0&#x27;&amp;&amp;mid[j]!=&#x27;\\0&#x27;;i++,j++)&#123;&#125;\t\t\t\tif(pre[i] == mid[j])&#123;\t\t\t\t\t//printf(&quot;%d\\n&quot;,i);\t\t\t\t\tbuildBT(pre,mid,&amp;newBt,i);\t\t\t\t\t//建树成功输出其后序遍历 \t\t\t\t\tpostOrderShowBT(newBt);\t\t\t\t\t//printf(&quot;mdfk\\n&quot;); \t\t\t\t&#125;else&#123;\t\t\t\t\tprintf(&quot;先序数组与后序数组长度不一致!\\n&quot;);\t\t\t\t&#125;\t\t\t\tbreak;\t\t\t&#125;\t\t\tcase &#x27;3&#x27;:&#123;\t  \t\t\tBT *newBt = NULL;\t  \t\t\tchar post[100],mid[100]; \t  \t\t\tprintf(&quot;请输入后序数组：&quot;);\t\t\t\tscanf(&quot;%s&quot;,post);\t\t\t\tgetchar();\t\t\t\tprintf(&quot;请输入中序数组：&quot;);\t\t\t\tscanf(&quot;%s&quot;,mid);\t\t\t\tgetchar();\t\t\t\tint i = 0,j = 0;\t\t\t\tfor(;post[i]!=&#x27;\\0&#x27;&amp;&amp;mid[j]!=&#x27;\\0&#x27;;i++,j++)&#123;&#125;\t\t\t\tif(post[i] == mid[j])&#123;\t\t\t\t\tpostMidBuildBT(post,mid,&amp;newBt,i);\t\t\t\t\t//建树成功输出其先序遍历\t\t\t\t\tpreOrderShowBT(newBt);\t\t\t\t&#125;else&#123;\t\t\t\t\tprintf(&quot;后序数组与后序数组长度不一致!\\n&quot;);\t\t\t\t&#125;\t\t\t\tbreak;\t\t\t&#125;\t\t\tcase &#x27;4&#x27;:\t\t\t\tif(bt)&#123;\t\t\t\t\tpreOrderShowBT(bt);\t\t\t\t&#125; else &#123;\t\t\t\t\tprintf(&quot;请先建一颗树吧！&quot;);\t\t\t\t&#125;\t\t\t\t\tbreak;\t\t\tcase &#x27;5&#x27;:\t\t\t\tif(bt)&#123;\t\t\t\t\tmidOrderShowBT(bt);\t\t\t\t&#125; else &#123;\t\t\t\t\tprintf(&quot;请先建一颗树吧！&quot;);\t\t\t\t&#125;\t\t\t\tbreak;\t\t\tcase &#x27;6&#x27;:\t\t\t\tif(bt)&#123;\t\t\t\t\tpostOrderShowBT(bt);\t\t\t\t&#125; else &#123;\t\t\t\t\tprintf(&quot;请先建一颗树吧！&quot;);\t\t\t\t&#125;\t\t\t\tbreak;\t\t\tcase &#x27;7&#x27;:\t\t\t\tif(bt)&#123;\t\t\t\t\tlevelOrderShowBT(bt);\t\t\t\t&#125; else &#123;\t\t\t\t\tprintf(&quot;请先建一颗树吧！&quot;);\t\t\t\t&#125;\t\t\t\tbreak;\t\t\tcase &#x27;8&#x27;:\t\t\t\tif(bt)&#123;\t\t\t\t\tprintf(&quot;树一共有%d个节点&quot;,getAllNodeCount(bt));\t\t\t\t&#125; else &#123;\t\t\t\t\tprintf(&quot;请先建一颗树吧！&quot;);\t\t\t\t&#125;\t\t\t\tbreak;\t\t\tcase &#x27;9&#x27;:\t\t\t\tif(bt)&#123;\t\t\t\t\tprintf(&quot;树的深度为:%d&quot;,getDepth(bt));\t\t\t\t&#125; else &#123;\t\t\t\t\tprintf(&quot;请先建一颗树吧！&quot;);\t\t\t\t&#125;\t\t\t\tbreak;\t\t\tcase &#x27;0&#x27; :\t\t\t\tch1=&#x27;n&#x27;;\t\t\t\tbreak;\t\t\tdefault:\t\t\t\tprintf(&quot;输入有误，请输入0~6进行选择!&quot;);\t\t\t&#125;\t\tprintf(&quot;\\n&quot;);\t\tsystem(&quot;pause&quot;);\t\t&#125;\treturn 0;&#125;\n\n图#include &lt;iostream&gt;#include &lt;stdlib.h&gt;#include &lt;limits.h&gt;using namespace std;const int MAX = 100;\t//最大存储节点typedef char DataType;\t//节点的数据类型 typedef int EdgeType;\t//边类的数据类型 bool v[MAX];\t//图搜索记录数组//MyEdgesGraph-邻接矩阵表示图 typedef struct&#123;\tint nodeNum,edgeNum;\t//节点总数量，边总数量 \tDataType vexs[MAX];\t\t//存储所有节点的数组 \tint edges[MAX][MAX];\t//邻接矩阵\t &#125;MyEdgesGraph; typedef struct ArcNode&#123;\tint vertexIndex;\t\t\t//节点下标 \tint arcData;\t\t\t\t//权重 \tstruct ArcNode *nextArc;\t//下邻接点 &#125;ArcNode;//存储边关系的节点typedef struct VertexNode&#123;\tDataType data;\t\t\t\t//头节点信息 \tArcNode *first;\t\t\t\t//表头指针,指向它的边 &#125;VertexNode;//存储顶点的节点\t //AdjList-邻接表表示图 typedef struct&#123;\tint nodeNum,edgeNum;\t\t//邻接表的节点数，边数 \tVertexNode vertexNode[MAX]; //邻接表数组 &#125;AdjList; MyEdgesGraph *createEdgesGraph()&#123;\t//判断是有向图输入还是无向图输入 \tprintf(&quot;请确认是无向图还是有向图？(1.无向，2.有向):&quot;);\tint choose;\tscanf(&quot;%d&quot;,&amp;choose);\tgetchar();\tif(choose != 1 &amp;&amp; choose != 2) return NULL;\t//如果输入不为1或者2，直接退出方法 \t\tMyEdgesGraph *graph = (MyEdgesGraph*)malloc(sizeof(MyEdgesGraph));\t//动态申请一块空间用于邻接矩阵存储图 \tprintf(&quot;请输入有多少个节点:&quot;);\tscanf(&quot;%d&quot;,&amp;graph-&gt;nodeNum);\t//存储节点数 \tgetchar();\t\t\t\t\t\t//getchar()用于读取缓存区的回车，防止后续读取字符出错 \tprintf(&quot;请输入有多少条边:&quot;);\tscanf(&quot;%d&quot;,&amp;graph-&gt;edgeNum);\t//存储边数 \tgetchar();\t\tprintf(&quot;请输入每个节点信息:&quot;);\tchar c;\tint i=1; \twhile(1)&#123;\t\t\t\t\t\t//存储节点信息 \t\tc = getchar();\t\tgraph-&gt;vexs[i++] = c;\t\tif(i&gt;graph-&gt;nodeNum) break;\t&#125;\tgetchar();\t\t\tif(choose == 1)&#123;\t\t//无向图 \t\tprintf(&quot;请输入边(节点编号,节点编号):&quot;);\t\tint x,y;\t//临时存储节点编号 \t\tfor(int i = 1; i&lt;=graph-&gt;edgeNum; i++)&#123;\t\t\tscanf(&quot;%d,%d&quot;,&amp;x,&amp;y);\t\t\tgetchar();\t\t\tgraph-&gt;edges[x][y] = 1;\t\t//将边标记 \t\t\tgraph-&gt;edges[y][x] = 1;\t\t//无向图,矩阵具有对称性 \t\t&#125;  \t\t\t\t&#125; else if(choose == 2)&#123;\t\t//有向图\t\t//先将矩阵初始化为最大值 \t\tfor(int i = 1;i&lt;=graph-&gt;nodeNum;i++)&#123;\t\t\tfor(int j = 1;j&lt;=graph-&gt;nodeNum;j++)&#123;\t\t\t\tgraph-&gt;edges[i][j] = INT_MAX;\t\t\t&#125;\t\t&#125; \t\tprintf(&quot;请输入边(节点编号,节点编号,权重):&quot;);\t\tint x,y,w;\t//临时存储节点编号与权重 \t\tfor(int i = 1; i&lt;=graph-&gt;edgeNum; i++)&#123;\t\t\tscanf(&quot;%d,%d,%d&quot;,&amp;x,&amp;y,&amp;w);\t\t\tgetchar();\t\t\tgraph-&gt;edges[x][y] = w;\t//将边标记为权重 \t\t&#125;  \t&#125;\tprintf(&quot;创建成功!&quot;);\treturn graph;&#125;void showEdges(MyEdgesGraph *graph)&#123;\tprintf(&quot;该图的邻接矩阵为：\\n&quot;);\tprintf(&quot;  &quot;);\tfor(int i = 1;i&lt;=graph-&gt;nodeNum;i++)\t\tprintf(&quot;%c   &quot;,graph-&gt;vexs[i]);\tprintf(&quot;\\n&quot;);\tfor(int i = 1;i&lt;=graph-&gt;nodeNum;i++)&#123;\t\tprintf(&quot;%c &quot;,graph-&gt;vexs[i]);\t\tfor(int j = 1;j&lt;=graph-&gt;nodeNum;j++)&#123;\t\t\tif(graph-&gt;edges[i][j] == INT_MAX)&#123;\t\t\t\tprintf(&quot;∞  &quot;);\t\t\t&#125;else\t\t\t\tprintf(&quot;%d   &quot;,graph-&gt;edges[i][j]);\t\t&#125;\t\tcout&lt;&lt;endl;\t&#125;\tprintf(&quot;节点数:%d&quot;,graph-&gt;nodeNum);\tprintf(&quot;\\n边数:%d&quot;,graph-&gt;edgeNum);&#125;AdjList *createAdjList()&#123;\t//判断是有向图输入还是无向图输入 \tprintf(&quot;请确认是无向图还是有向图？(1.无向，2.有向):&quot;);\tint choose;\tscanf(&quot;%d&quot;,&amp;choose);\tgetchar();\tif(choose != 1 &amp;&amp; choose != 2) return NULL;\t\t\t//如果输入不为1或者2，直接退出方法\t\tAdjList *graph = (AdjList*)malloc(sizeof(AdjList));\t//动态声明一块空间存储邻接表 \tprintf(&quot;请输入有多少个节点:&quot;);\tscanf(&quot;%d&quot;,&amp;graph-&gt;nodeNum);\t\t\t\t\t\t//存储节点数 \tgetchar();\tprintf(&quot;请输入有多少条边:&quot;);\t\t\t\t\t\t\tscanf(&quot;%d&quot;,&amp;graph-&gt;edgeNum);\t\t\t\t\t\t//存储边数 \tgetchar();\t\tprintf(&quot;请输入每个节点信息:&quot;);\tchar c;\tint i=1; \twhile(1)&#123;\t\t\t\t\t\t\t\t\t\t\t//存储边信息 \t\tc = getchar();\t\tgraph-&gt;vertexNode[i].first = NULL;\t\tgraph-&gt;vertexNode[i++].data = c;\t\tif(i&gt;graph-&gt;nodeNum) break;\t&#125;\tgetchar();\t\tif(choose == 1)&#123;\t\t//无向边 \t\tprintf(&quot;请输入边(节点编号,节点编号,权重):&quot;);\t\tint x,y,z;\t\t//节点编号,节点编号,权重\t\tfor(int i = 1; i&lt;=graph-&gt;edgeNum; i++)&#123;\t\t\tscanf(&quot;%d,%d,%d&quot;,&amp;x,&amp;y,&amp;z);\t\t\tgetchar();\t\t\tArcNode *node = (ArcNode*)malloc(sizeof(ArcNode));\t\t//动态声明一块空间存储边关系 \t\t\t//先存储该边信息 \t\t\tnode-&gt;vertexIndex = y;\t\t\t\t\t\t\t\t\t//边相连的另一边 \t\t\tnode-&gt;arcData = z;\t\t\t\t\t\t\t\t\t\t//存储权重 \t\t\t//采用头插法，将头节点与边相连接 \t\t\tnode-&gt;nextArc = graph-&gt;vertexNode[x].first;\t\t\t\t \t\t\tgraph-&gt;vertexNode[x].first = node;\t\t\t//无向图所以可以x-&gt;y和y-&gt;x\t\t\tArcNode *node1 = (ArcNode*)malloc(sizeof(ArcNode));\t\t\tnode1-&gt;vertexIndex = x;\t\t\tnode1-&gt;arcData = z;\t\t\tnode1-&gt;nextArc = graph-&gt;vertexNode[y].first;\t\t\tgraph-&gt;vertexNode[y].first = node1;\t\t&#125;  \t\t\t\t&#125; else if(choose == 2)&#123;\t\tprintf(&quot;请输入边(节点编号,节点编号,权重):&quot;);\t\tint x,y,z;\t\tfor(int i = 1; i&lt;=graph-&gt;edgeNum; i++)&#123;\t\t\tscanf(&quot;%d,%d,%d&quot;,&amp;x,&amp;y,&amp;z);\t\t\tgetchar();\t\t\tArcNode *node = (ArcNode*)malloc(sizeof(ArcNode));\t\t\t\t\t\tnode-&gt;vertexIndex = y;\t\t\tnode-&gt;arcData = z;\t\t\tnode-&gt;nextArc = graph-&gt;vertexNode[x].first;\t\t\tgraph-&gt;vertexNode[x].first = node;\t\t\t\t\t&#125;  \t&#125;\tprintf(&quot;创建成功!&quot;);\treturn graph;\t&#125;void showAdjList(AdjList *graph)&#123;\tfor(int i = 1;i&lt;=graph-&gt;nodeNum;i++)&#123;\t\tprintf(&quot;下标:%d 节点:%c 边:&quot;,i,graph-&gt;vertexNode[i].data);\t\tArcNode *node = graph-&gt;vertexNode[i].first;\t\twhile(node != NULL)&#123;\t\t\tprintf(&quot; (%d,%d)&quot;,node-&gt;vertexIndex,node-&gt;arcData);\t\t\tnode = node-&gt;nextArc;\t\t&#125;\t\tprintf(&quot;\\n&quot;);\t&#125;&#125;void dfs_adjList(AdjList *graph,int index)&#123;\tprintf(&quot;%c &quot;,graph-&gt;vertexNode[index].data);\t\t\t//打印当前节点信息 \tv[index] = true;\t\t\t\t\t\t\t\t\t\t//设置当前节点已经访问 \tArcNode *node = graph-&gt;vertexNode[index].first;\t\t\t//获取与该点相连的边 \twhile(node != NULL)&#123;\t\t\t\t\t\t\t\t\t//如果有边则将边相连的另一节点递归遍历 \t\tif(!v[node-&gt;vertexIndex])\t\t\t\t\t\t\t//但是，与边相连的另一节点要没有遍历过才递归调用 \t\t\tdfs_adjList(graph,node-&gt;vertexIndex);\t\tnode = node-&gt;nextArc;\t\t\t\t\t\t\t\t//更新当前节点的边 \t&#125;&#125;void dfs_edges(MyEdgesGraph *graph,int index)&#123;\tprintf(&quot;%c &quot;,graph-&gt;vexs[index]);\t\t\t\t\t\t//打印当前节点信息 \tv[index] = true;\t\t\t\t\t\t\t\t\t\t//设置当前节点已经访问 \tfor(int i = 1;i&lt;=graph-&gt;nodeNum;i++)&#123;\t\t\t\t\t//循环遍历矩阵 \t\tif(graph-&gt;edges[index][i] != 0 &amp;&amp; !v[i] &amp;&amp; graph-&gt;edges[index][i] != INT_MAX)&#123;//如果有边则将边相连的另一节点递归遍历 \t\t\tif(!v[i])\t\t\t\t\t\t\t\t\t\t//但是，与边相连的另一节点要没有遍历过才递归调用 \t\t\t\tdfs_edges(graph,i);//递归 \t\t&#125;\t&#125;&#125;void bfs_adjList(AdjList *graph,int index)&#123;\tint q[MAX],front = 0,rear = 0;\t//循环队列 \tint nowNode,nextNode;\t\t\t//当前节点与下一节点\tq[rear++] = index;\t\t\t\t//将index入队 \tv[index] = true;\t\t\t\t//设置当前节点已经访问 \twhile(front != rear)&#123;\t\t\t//队列不为空 (队首与队尾指针相同时队列为空) \t\t\t\tnowNode = q[front];\t\t\t//将队首出队赋值给当前节点 \t\tfront = (front+1) % MAX; \t//出队后更新队头指针\t\tprintf(&quot;%c &quot;,graph-&gt;vertexNode[nowNode].data);\t\t//打印 \t\t\t\tArcNode* arcNode = graph-&gt;vertexNode[nowNode].first;\t\t//取出与当前节点相连的第一条边 \t\twhile(arcNode != NULL)&#123;\t\t\t\t\t//如果不存在边则无节点入队 \t\t\tnextNode = arcNode-&gt;vertexIndex;\t//下一节点\t \t\t\tif(!v[nextNode])&#123;\t//如果下一节点没有访问 \t\t\t\tv[nextNode] = true;\t\t//标记下一节点已经访问\t\t\t\tq[rear] = nextNode;\t\t//入队 \t\t\t\trear = (rear+1)%MAX;\t//更新尾指针 \t\t\t&#125;\t\t\tarcNode = arcNode-&gt;nextArc;\t//取出与当前节点相连的下一条边\t\t&#125;\t&#125;&#125;void bfs_edges(MyEdgesGraph *graph,int index)&#123;\tint q[MAX],front = 0,rear = 0;\t//循环队列 \tint nowNode,nextNode;\t//当前节点与下一节点 \tq[rear++] = index;\t\t//将index入队 \tv[index] = true;\t//设置当前节点已经访问 \twhile(rear != front)&#123;\t//当队列不为空(队首与队尾指针相同时队列为空) \t\t\t\tnowNode = q[front];\t\t//将队首出队\t\tfront = (front+1)%MAX;\t//更新队头指针 \t\tprintf(&quot;%c &quot;,graph-&gt;vexs[nowNode]);\t//打印节点信息 \t\t\t\tfor(int i = 1;i&lt;=graph-&gt;nodeNum;i++)&#123;\t//将与该节点有边相连的节点入队 \t\t\tif(graph-&gt;edges[nowNode][i] != 0 &amp;&amp; graph-&gt;edges[nowNode][i] != INT_MAX)&#123;\t//权重不为0或者不为最大值表明有边 \t\t\t\tnextNode = i;\t\t\t\tif(!v[nextNode])&#123;\t\t\t\t//如果下一节点没有访问，则入队 \t\t\t\t\tq[rear] = nextNode;\t\t\t//入队 \t\t\t\t\trear = (rear+1)%MAX;\t\t//更新尾指针 \t\t\t\t\tv[nextNode] = true;\t//设置当前节点已经访问 \t\t\t\t&#125;\t\t\t&#125;\t\t&#125;\t&#125;\t&#125;void menu()&#123;    printf(&quot;\\n图的各种操作&quot;);  printf(&quot;\\n========================================&quot;);  printf(&quot;\\n|          1--建立邻接矩阵             |&quot;);  printf(&quot;\\n|          2--显示邻接矩阵             |&quot;);  printf(&quot;\\n|          3--建立邻接表               |&quot;);  printf(&quot;\\n|          4--显示邻接表               |&quot;);  printf(&quot;\\n|          5--图的DFS-邻接矩阵         |&quot;);  printf(&quot;\\n|          6--图的DFS-邻接表           |&quot;);  printf(&quot;\\n|          7--图的BFS-邻接矩阵         |&quot;);  printf(&quot;\\n|          8--图的BFS-邻接表           |&quot;);  printf(&quot;\\n|          0--返回                     |&quot;);  printf(&quot;\\n========================================&quot;);  printf(&quot;\\n请输入菜单号(0-8)：&quot;);&#125; int main()&#123;\tchar ch1,ch2;\tMyEdgesGraph *edgesGraph = NULL;\tAdjList *adjList = NULL;\tch1=&#x27;y&#x27;;\t\t\twhile(ch1==&#x27;y&#x27;||ch1==&#x27;Y&#x27;)&#123;\t\tmenu();\t\tscanf(&quot;%c&quot;,&amp;ch2);\t\tgetchar();\t\tswitch(ch2)\t\t&#123;\t\t\tcase &#x27;1&#x27;:\t\t\t\t&#123;\t\t\t\t\tedgesGraph = createEdgesGraph();\t\t\t\t\t\t\t\t\t&#125;\t\t\t\tbreak;\t  \t\tcase &#x27;2&#x27;:\t  \t\t\t&#123;\t  \t\t\t\tif(edgesGraph != NULL)\t  \t\t\t\t\tshowEdges(edgesGraph);\t  \t\t\t\telse\t  \t\t\t\t\tprintf(&quot;请先创建邻接矩阵!&quot;);\t  \t\t\t\t\t\t\t\t&#125;\t\t\t\tbreak;\t\t\tcase &#x27;3&#x27;:\t\t\t\t&#123;\t\t\t\t\tadjList = createAdjList();\t\t\t\t\t\t\t\t\t&#125;\t\t\t\tbreak;\t\t\tcase &#x27;4&#x27;:\t\t\t\t&#123;\t\t\t\t\tif(adjList != NULL)\t  \t\t\t\t\tshowAdjList(adjList);\t  \t\t\t\telse\t  \t\t\t\t\tprintf(&quot;请先创建邻接表!&quot;);\t  \t\t\t\t\t\t\t\t\t&#125;\t\t\t\tbreak;\t\t\tcase &#x27;5&#x27;:\t\t\t\t&#123;\t\t\t\t\tif(edgesGraph != NULL)&#123;\t\t\t\t\t\tfor(int i =1;i&lt;=edgesGraph-&gt;nodeNum;i++)&#123;\t\t\t\t\t\t\tif(!v[i]) dfs_edges(edgesGraph,i);\t\t\t\t\t\t&#125; \t\t\t\t\t\t//搜索后将访问数组恢复初始状态，便于下次搜索 \t\t\t\t\t\tfor(int i =1;i&lt;=edgesGraph-&gt;nodeNum;i++)&#123;\t\t\t\t\t\t\tv[i] = false;\t\t\t\t\t\t&#125; \t\t\t\t\t&#125;else\t  \t\t\t\t\tprintf(&quot;请先创建邻接矩阵!&quot;);\t\t\t\t&#125;\t\t\t\tbreak;\t\t\tcase &#x27;6&#x27;:\t\t\t\t&#123;\t\t\t\t\tif(adjList != NULL)&#123;\t\t\t\t\t\tfor(int i =1;i&lt;=adjList-&gt;nodeNum;i++)&#123;\t\t\t\t\t\t\tif(!v[i]) dfs_adjList(adjList,i);\t\t\t\t\t\t &#125; \t\t\t\t\t\t //搜索后将访问数组恢复初始状态，便于下次搜索 \t\t\t\t\t\tfor(int i =1;i&lt;=adjList-&gt;nodeNum;i++)&#123;\t\t\t\t\t\t\tv[i] = false;\t\t\t\t\t\t&#125; \t\t\t\t\t\t&#125;else\t  \t\t\t\t\tprintf(&quot;请先创建邻接表!&quot;);\t\t\t\t&#125;\t\t\t\tbreak;\t\t\tcase &#x27;7&#x27;:\t\t\t\t&#123;\t\t\t\t\tif(edgesGraph != NULL)&#123;\t\t\t\t\t\tfor(int i =1;i&lt;=edgesGraph-&gt;nodeNum;i++)&#123;\t\t\t\t\t\t\tif(!v[i]) bfs_edges(edgesGraph,i);\t\t\t\t\t\t &#125; \t\t\t\t\t\t //搜索后将访问数组恢复初始状态，便于下次搜索 \t\t\t\t\t\tfor(int i =1;i&lt;=edgesGraph-&gt;nodeNum;i++)&#123;\t\t\t\t\t\t\tv[i] = false;\t\t\t\t\t\t&#125; \t\t\t\t\t\t&#125;else\t  \t\t\t\t\tprintf(&quot;请先创建邻接矩阵!&quot;);\t\t\t\t&#125;\t\t\t\tbreak;\t\t\tcase &#x27;8&#x27;:\t\t\t\t&#123;\t\t\t\t\tif(adjList != NULL)&#123;\t\t\t\t\t\tfor(int i =1;i&lt;=adjList-&gt;nodeNum;i++)&#123;\t\t\t\t\t\t\tif(!v[i]) bfs_adjList(adjList,i);\t\t\t\t\t\t &#125;\t\t\t\t\t\t //搜索后将访问数组恢复初始状态，便于下次搜索  \t\t\t\t\t\tfor(int i =1;i&lt;=adjList-&gt;nodeNum;i++)&#123;\t\t\t\t\t\t\tv[i] = false;\t\t\t\t\t\t&#125; \t\t\t\t\t\t&#125;else\t  \t\t\t\t\tprintf(&quot;请先创建邻接表!&quot;);\t\t\t\t&#125;\t\t\t\tbreak;\t\t\tcase &#x27;0&#x27; :\t\t\t\tch1=&#x27;n&#x27;;\t\t\t\tbreak;\t\t\tdefault:\t\t\t\tprintf(&quot;输入有误，请输入0~8进行选择!&quot;);\t\t&#125;\t\tprintf(&quot;\\n&quot;);\t\tsystem(&quot;pause&quot;);\t\t&#125;\treturn 0;&#125;\n\n未完待续……算法最短路径朴素版Dijkstra算法\n参考题目:acwing-最短路径\n\n#include &lt;iostream&gt;#include &lt;cstring&gt;using namespace std;//稠密图使用朴素版dijkstra,时间复杂度为o(n*n)const int MAX = 510;    //最大节点数int g[MAX][MAX];        //邻接矩阵bool v[MAX];            //已经访问了的到起点的距离最短的点int pre[MAX];           //并查集,用于记录最短路径int dijkstra(int n,int m)&#123;    int dist[MAX];  //存储每个点到起点的最短距离    for(int i = 0;i&lt;=n;i++)&#123;        pre[i] = i; //初始化每个点都以自己为一个集合    &#125;    memset(dist,0x3f,sizeof dist);  //初始化设为无穷大    dist[1] = 0;                    //本题起点是1,起点到起点的距离设为0    //1号节点对dist进行更新会导致一直为无穷大    for(int i = 0;i&lt;n;i++)&#123; //最多n次迭代        int k = -1; //还未找到最小值时k为-1        for(int j = 1;j&lt;= n;j++)&#123;   //遍历dist数组，找到距离起点的最小距离，赋值给k            if(!v[j] &amp;&amp; (k == -1 || dist[j] &lt; dist[k])) //当然，如果该点已经求得到原点的距离最小则不用在比较                k = j;        &#125;                v[k] = true;    //将到起点的距离最小的点标记        if(k == n) break;   //如果该点正好是要求的终点则直接退出迭代                for(int j = 1;j&lt;=n;j++)&#123;    //更新dist数组            if(!v[j]&amp;&amp;dist[j] &gt; dist[k] + g[k][j])&#123;  //如果该点还未被标记，且从原点到k加上k到该点j的距离，比曾经原点到j距离更近，则更新原点到该点的距离                dist[j] = dist[k] + g[k][j];                pre[j] = k;     //更新该节点从起始位置经过k到达j距离最近，也就是说j节点的父节点为k            &#125;        &#125;    &#125;        if(dist[n] == 0x3f3f3f3f) return -1;    //如果起点到终点最短距离为无穷大则表明图未联通    int hh = n; //从终点开始逆推到起点    while(hh != pre[hh])&#123;   //起点满足自己的上一节点是自己        printf(&quot;%d-&gt;&quot;,hh);   //打印该节点        hh = pre[hh];       //继续查找自己的上一节点是不是起点    &#125;    printf(&quot;1&quot;);    return dist[n];&#125;int main()&#123;    int n,m;    scanf(&quot;%d %d&quot;,&amp;n,&amp;m);        memset(g,0x3f,sizeof g);        for(int i = 0;i&lt;m;i++)&#123;        int u,v,w;        scanf(&quot;%d %d %d&quot;,&amp;u,&amp;v,&amp;w);        g[u][v] = min(g[u][v],w);    &#125;    int res = dijkstra(n,m);    printf(&quot;\\n%d&quot;,res);    return 0;&#125;\n\n堆优化版Dijkstra算法\n参考题目：Dijkstra求最短路 II\n\n#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;queue&gt;using namespace std;typedef pair&lt;int,int&gt; PII;  //(离起始点最短距离，节点编号)const int MAX = 200005;//数组模拟邻接表，head[]数组是链表头，e[]数组存储的是节点编号，ne[]数组存储的是下一节点指针//idx开辟新空间指针，w[]数组存储的是该节点的权重int head[MAX],e[MAX],w[MAX],ne[MAX],idx;bool v[MAX];    //记录节点是否被选出void init(int n)&#123;    //邻接表初始化    for(int i = 0;i&lt;=n;i++) head[i] = -1;   //将每个节点表头设为-1    idx = 0;&#125;//插入边关系 a-&gt;b,c为权重void insert_head(int a,int b,int c)&#123;    e[idx] = b; //存储与head[a]相连边的节点编号    w[idx] = c; //存储边权重    ne[idx] = head[a];  //头插法    head[a] = idx;    idx++;  //指针加1&#125;int dijkstra(int n,int m)&#123;    int dist[MAX];  //存储各节点到起点的距离    memset(dist,0x3f,sizeof dist);  //初始化距离为无穷大    dist[1] = 0;    //起点到起点距离为1    priority_queue&lt;PII,vector&lt;PII&gt;,greater&lt;PII&gt;&gt; q; //优先队列，按照升序排序    q.push(&#123;0,1&#125;);  //将节点1入队    while(q.size())&#123;        //只要队不为空则进行循环        PII x = q.top();    //取出队首元素，取出的元素总是到原点的最小距离，这步骤就是朴素版的查询dist[]数组的最小值        q.pop();            //将其出队        int now = x.second,weight = x.first;    //now表示现在这个节点的编号，weight表示权重        if(v[now]) continue;    //如果该边已经被选中了，则continue        v[now] = true;          //反之将该节点标记为已经选中                //用选中的节点更新dist[]数组        for(int i = head[now];i!=-1;i = ne[i])&#123;//链表查询，查询与被选中节点连通的节点，更新其到起点的最短距离            int node = e[i];    //与被选节点相连接的节点编号            if(!v[node] &amp;&amp; dist[node] &gt; weight+w[i])&#123;   //如果该节点未选中过且原来到原点的距离比通过被选节点到原点距离远则更新距离                dist[node] = w[i] + weight;                q.push(&#123;dist[node],node&#125;);  //更新后入队            &#125;        &#125;    &#125;    if(dist[n] == 0x3f3f3f3f) return -1;    //如果距离出现无穷大说明图未联通    return dist[n];    &#125;int main()&#123;    int n,m;    scanf(&quot;%d %d&quot;,&amp;n,&amp;m);    init(n);    for(int i = 0;i&lt;m;i++)&#123;        int x,y,z;        scanf(&quot;%d %d %d&quot;,&amp;x,&amp;y,&amp;z);        insert_head(x,y,z);    &#125;    int ans = dijkstra(n,m);    printf(&quot;%d&quot;,ans);    return 0;  &#125;\n\n最小生成树prim算法\n参考题目:acwing-最小生成树\n\n#include &lt;iostream&gt;#include &lt;limits.h&gt;using namespace std;const int MAX = 510;\t//邻接矩阵节点数最大值 int graph[MAX][MAX];\t//邻接矩阵 //prim算法，获取最小生成树与其权重和 int prim(int nodes,int edges)&#123;\tint pre[MAX],dist[MAX],ans = 0;\t//pre数组记录最小生成树的连接关系pre[3] = 2,表示到节点3的最短距离是节点2\t\t\t\t\t\t\t//dist数组代表距离已经添加到最小生成树的节点集合的最小距离 \tbool v[MAX];\t\t\t//记录已经添加进最小生成树集合的元素\tfor(int i = 1;i&lt;=nodes;i++)&#123;\t\tdist[i] = INT_MAX;\t//初始化距离数组为最大值 \t\tpre[i] = -1;\t\tv[i] = false;\t&#125; \tfor(int i = 0;i&lt;nodes;i++)&#123;\t//最小生成树连接了所有节点，所以是nodes次迭代，每次连接一个节点 \t\tint min = -1;\t\t//用于记录dist数组的最小值 \t\tfor(int j = 1;j&lt;=nodes;j++)&#123;\t//枚举每一个没有被加入最小生成树的节点，找出dist数组中距离最小生成树集合最近的节点 \t\t\tif(!v[j] &amp;&amp; (min == -1 || dist[j] &lt; dist[min]))&#123;\t//这里如果min == -1 表示第一次寻找，特殊处理一下 \t\t\t\tmin = j;\t\t\t&#125;\t\t&#125;\t\tif(i &amp;&amp; dist[min] == INT_MAX) return INT_MAX;\t//除了第一次节点选择会出现到最小生成树集合最小距离为无穷大情况，如果其他时候出现了表明，该图未联通        \t\tv[min] = true;\t//找到最小值后，将其加入最小生成树集合 \t\tif(i) ans+=dist[min];\t//加上权重,排除第一次选择节点时，由于初始化的dist为无穷大 \t\t//之后更新dist数组,因为最小生成树集合新加了元素，所以更新下dist数组(各节点到最小生成树集合的距离最小值) \t\tfor(int j = 1;j&lt;=nodes;j++)&#123;\t\t\tif(!v[j] &amp;&amp; dist[j]&gt;graph[j][min])&#123;\t\t\t\tdist[j] = graph[j][min];\t\t\t\tpre[j] = min;\t\t\t&#125; \t\t&#125;  \t&#125;\tfor(int i = 1;i&lt;=nodes;i++) printf(&quot;%d-&gt;%d &quot;,pre[i],i);\treturn ans;&#125;int main()&#123;\tint nodes,edges; //节点总数，边数\tint u,v,w;\t\t//节点编号u,v 权重w \tscanf(&quot;%d %d&quot;,&amp;nodes,&amp;edges);\t//获取到节点数与边数 \tfor(int i = 0;i&lt;=nodes;i++)&#123;\t//初始化邻接矩阵 \t\tfor(int j = 0;j&lt;=nodes;j++)&#123;\t\t\tif(i == j) graph[i][j] = 0; \t\t\telse graph[i][j] = INT_MAX;\t\t&#125;\t&#125;\tfor(int i = 1;i&lt;=edges;i++)&#123;\t    scanf(&quot;%d %d %d&quot;,&amp;u,&amp;v,&amp;w);\t//读取边信息 \t    graph[u][v] = graph[v][u] = graph[u][v]&gt;w?w:graph[u][v];\t&#125; \tint res = prim(nodes,edges);\tif(res != INT_MAX) printf(&quot;%d&quot;,res);\telse printf(&quot;impossible&quot;);\treturn 0;&#125;\n\nkruskal算法\n参考题目:Kruskal算法求最小生成树\n\n#include &lt;iostream&gt;using namespace std;const int MAX = 100005;//结构体用于存储边 typedef struct&#123;\tint a,b,w;\t//端点a,b,权重w &#125;Edge;int p[MAX];\t//并查集数组，并查集数据结构可以快速的合并集合，查询某元素属于哪个集合等操作 void quick_sort(Edge q[],int l,int r)&#123;  //用快速排序算法，文中有具体算法解释，也可以用库函数中的sort()\tif(l&gt;=r) return;\tint i = l-1,j = r+1;\tEdge x = q[l+r&gt;&gt;1];\twhile(i&lt;j)&#123;\t\tdo i++; while(q[i].w &lt; x.w);\t\tdo j--; while(q[j].w &gt; x.w);\t\tif(i&lt;j) swap(q[i],q[j]);\t&#125;\tquick_sort(q,l,j);\tquick_sort(q,j+1,r);&#125;int find(int x)&#123;    //查询某一元素输入哪个集合(查询根节点),并进行路径压缩\tif(p[x] != x) p[x] = find(p[x]);    //如果某元素x的父节点不是自己，则查询其父亲节点是否是根节点\treturn p[x];    //如果是，返回父亲节点，并赋值给子节点，也就是说将所有子节点的父亲都设为根节点，这样有利于以后查询&#125;int kruskal(Edge edges[],int nodes,int m)&#123;\tquick_sort(edges,0,m-1);        //先对边进行排序\tint res = 0,cnt = 0;\tfor(int i = 0;i&lt;m;i++)&#123;         //只要两节点没有连接，则进行连接\t\tint a = edges[i].a,b = edges[i].b,w = edges[i].w;\t\ta = find(a),b = find(b);    //查询两节点属于哪个集合\t\tif(a != b)&#123;                 //如果不属于同集合，表明两点未连接\t\t\tp[a] = b;               //更新某节点的父亲，也就是合并两集合\t\t\tres+=w;                 //更新权重\t\t\tcnt++;                  //连接的节点数加1\t\t&#125;\t&#125;\tif(cnt &lt; nodes-1) return 0x3f;  //如果图是连通的那么其连接的节点数一定是n-1(由于计数是从0开始，每次连接的是两节点，当第一次连接的时候cnt只累加了一次)\treturn res;&#125;int main()&#123;\tint nodes,m;\t//节点数和边数 \tEdge edges[2 * MAX];\t//存储边的数组 \tscanf(&quot;%d %d&quot;,&amp;nodes,&amp;m);\tfor(int i = 1;i&lt;=nodes;i++) p[i] = i;\t//初始化并查集数组，每个元素都是一个集合\tfor(int i = 0;i&lt;m;i++)&#123;\t\tint a,b,w;\t\tscanf(&quot;%d %d %d&quot;,&amp;a,&amp;b,&amp;w);\t\tedges[i] = &#123;a,b,w&#125;;\t\t\t\t\t//读入边信息 \t&#125; \tint res = kruskal(edges,nodes,m);\tif(res == 0x3f) printf(&quot;impossible&quot;);   //图未联通\telse printf(&quot;%d&quot;,res);                  \treturn 0;&#125;\n\n排序插入排序#include &lt;iostream&gt;using namespace std;int num[100];//插入排序//区间0-n可分为两个区间，0 - a为已经排序后的区间，a+1 - n为未排序区间//算法思路：//两个指针，指针i指向未排序区间第一个元素作为待插入元素，指针j指向排序后区间的最后一个元素 //先将i指针指向的元素取出存储到temp中，随后temp与排序的区间进行比较，从j指向的元素开始查找到他本该在的位置//即temp与num[j]进行比较 ：//\t1.(升序)如果temp大于等于j指定的元素那么待插入元素的位置就在当前位置 //  2.小于，则表明在j指向的前方，所以把j元素移动到j+1位置，为插入temp腾出位置，随后j--,继续进行比较直到找到合适的位置 int main()&#123;\tint n;\tcin&gt;&gt;n;\tfor(int i = 0;i&lt;n;i++) cin&gt;&gt;num[i];\tfor(int i = 1;i&lt;n;i++)&#123;\t\t//从先将待插入元素取出，存到temp中\t\t//定义j指针，指向排序后区间的最后一个元素\t\tint temp = num[i],j = i-1;\t\t//循环判断待插入元素与j指向的元素的大小关系 \t\twhile(j &gt;= 0 &amp;&amp; temp&lt;num[j])&#123;\t\t\t//如果小于则位置在j之前，先将j指向的元素移向j+1为temp腾位置 \t\t\tnum[j+1] = num[j];\t\t\tj--;\t//指针减一，继续判断 \t\t&#125;\t\tnum[j+1] = temp;\t//查询到了合适位置后，插入到j元素后方 \t&#125;\tfor(int i = 0;i&lt;n;i++) cout&lt;&lt;num[i]&lt;&lt;&quot; &quot;;&#125;\n\n快速排序\n参考题目：快速排序\n\n#include &lt;iostream&gt;using namespace std;const int MAX = 100005;int num[MAX];void quick_sort(int q[],int l,int r)&#123;    if(l&gt;=r) return;        //递归结束条件    //定义两个指针i,j     int i = l-1,j = r+1,k = q[l+r&gt;&gt;1];  //k可取任意值,但是该模板取中间值最快      while(i&lt;j)&#123;        //左指针先循环查找到大于k的值,随后右指针循环查找到小于k的值        do&#123;            i++;        &#125;while(q[i]&lt;k);        do&#123;            j--;        &#125;while(q[j]&gt;k);        //如果左指针小于右指针则将左指针与右指针的内容进行交换        if(i&lt;j) swap(q[i],q[j]);    &#125;        quick_sort(q,l,j);  //递归处理数组左边    quick_sort(q,j+1,r);    //递归处理数组右边&#125;int main()&#123;    int n;    scanf(&quot;%d&quot;,&amp;n);    for(int i = 0;i&lt;n;i++) scanf(&quot;%d&quot;,&amp;num[i]);    quick_sort(num,0,n-1);    for(int i = 0;i&lt;n;i++) printf(&quot;%d &quot;,num[i]);&#125;\n\n归并排序\n参考题目:归并排序\n\n#include &lt;iostream&gt;using namespace std;const int MAX = 100005;int m[MAX],temp[MAX];void merge_sort(int p[],int l,int r)&#123;    if(l&gt;=r) return;    //如果没有元素可以排序则直接return    int mid = l+r&gt;&gt;1;   //将数组一分为二    merge_sort(p,l,mid);    //左边数组进行排序    merge_sort(p,mid+1,r);  //右边数组进行排序    //将已经排好序的左右数组归并    int i = l,j = mid+1,k = 0;  //i指向左边第一个元素，j指向右边第一个元素    while(i&lt;=mid &amp;&amp; j&lt;=r)&#123;          //如果左边元素小于等于右边元素，则将其放入临时数组，左指针加1，反之        if(p[i]&lt;=p[j]) temp[k++] = p[i++];        else temp[k++] = p[j++];    &#125;    //如果左或者右指针还有元素未存到临时数组中，则将其直接放在临时数组中    while(i&lt;=mid) temp[k++] = p[i++];    while(j&lt;=r) temp[k++] = p[j++];    //最后将临时数组的值放回原数组    for(i = l,j = 0; i &lt;= r;i++,j++) p[i] = temp[j];&#125;int main()&#123;    int n;    scanf(&quot;%d&quot;,&amp;n);    for(int i = 0;i&lt;n;i++) scanf(&quot;%d&quot;,&amp;m[i]);    merge_sort(m,0,n-1);    for(int i = 0;i&lt;n;i++) printf(&quot;%d &quot;,m[i]);    return 0;&#125;\n","categories":["数据结构与算法"],"tags":["c","数据结构与算法","栈","顺序表","链表","队列","树","串"]},{"title":"背包问题之求具体方案","url":"/2021/11/d1d91b2b7f7b.html","content":"题目来源https://www.acwing.com/problem/content/12/\n\n题目有 N 件物品和一个容量是 V 的背包。每件物品只能使用一次。\n第 i 件物品的体积是 vi，价值是 wi。\n求解将哪些物品装入背包，可使这些物品的总体积不超过背包容量，且总价值最大。\n输出 字典序最小的方案。这里的字典序是指：所选物品的编号所构成的序列。物品的编号范围是1…N。\n输入格式第一行两个整数，N，V，用空格隔开，分别表示物品数量和背包容积。\n接下来有 N 行，每行两个整数 vi,wi，用空格隔开，分别表示第 i 件物品的体积和价值。\n输出格式输出一行，包含若干个用空格隔开的整数，表示最优解中所选物品的编号序列，且该编号序列的字典序最小。\n物品编号范围是 1…N。\n数据范围0&lt;N,V≤1000\n0&lt;vi,wi≤1000\n输入样例4 51 22 43 44 6\n\n输出样例1 4\n\n本题DP思想1.dp数组的定义：dp[i][j]表示考虑了是否选第i个物品以及之后的所有物品之后背包容量不超过j的最优解(价值最大)\n2.状态转移:dp[i][j] &#x3D; max(dp[i+1][j],dp[i+1][j-v[i]])，状态可以通过(选，不选)来进行转移，它是由上一状态不选第i个物品或者上一状态选第i个物品转移得到.\n\n当dp[i][j] &#x3D; dp[i+1][j]上一状态且不选第i个物品：这时候的上一状态根据定义就是，考虑第i+1个物品以及之后的所有物品,且背包容量最大不超过j时这个状态,由于未选所以当前状态是直接由上一状态转移\n当dp[i][j] &#x3D; dp[i+1][j-v[i]]+w[i]上一状态选第i个物品：这时候的上一状态根据定义就是，考虑第i+1个物品以及之后的所有物品,且背包容量最大不超过j-v[i]时这个状态(状态转移之后背包体积为j，那么转移之前背包体积肯定就是减去选这个物品的体积啦)，所以当前状态等于上一状态加上当前所选物品的价值\n由于求的最优解，所以要从这两种状态转移中选择价值最大的\n\n3.初始化:由于dp是从最后一个物品开始，所以初始状态是dp[n+1][j]，套上状态定义就是考虑了第n+1个物品及其以后的所以物品且,背包最大体积不超过j的最优解。由于不存在第n+1个物品及其以后的所有物品，所以这时候dp[n+1]x的最优解就是0\n4.本题输出状态转移路径的解释：我们已经有状态转移数组了，我们再通过状态转移数组倒推具体是怎样转移的；可以这样理解，我们记录各种状态转移，并且得到了最优解，现在我们背包里已经装了东西(最优价值),我们枚举每一件物品判断这件物品是否装入了背包里，如果装入了我们就将物品编号输出，然后将该物品从背包中取出，关键就在于怎么判断它是否装入了？这时候就要用到状态转移数组：m-当前最大背包容量，我们判断dp[i]m这个状态是否是dp[i+1]m-v[i]通过装入第i个物品所转移得到的如果是则输出选择的物品序号，并将该物品从背包中取出，取出后背包最大体积为m &#x3D; m-v[i]，下一次我们又判断dp[i+1][m]这个状态是否是dp[i+1+1][m-v[i+1]]转移得到，代码处还有样例解释\n5.为什么要倒着dp?\n题目要求要输出字典序最小，如果1,2,3与1,2,4都能得到最优解，那么应该输出1,2,3.能选3就不能跳过3不选。所以我们应该倒着dp(用下面这个定义考虑，dp[1][V]就表明考虑了第一个及其以后的物品-&gt;也就是所有物品后，背包体积不超过V的时刻)然后顺着考虑转移路径，这个定义就是在表明，现在我们背包里已经装了东西(最优价值),我们枚举每一件物品判断这件物品是否装入了背包里，如果装入了我们就将物品编号输出，然后将该物品从背包中取出，怎么表达取出物品？就是背包的最大体积减少!\nAC代码#include &lt;iostream&gt;#include &lt;queue&gt;using namespace std;const int MAX = 1003;int dp[MAX][MAX],v[MAX],w[MAX];/** * n-物品总数，V-背包最大容量，dp[MAX][MAX]-状态数组，v[MAX]-存储每个物品体积的数组，w[MAX]-存储每个物品价值的数组 */int main()&#123;    int n,V;    //n-物品总数,V-背包总量    cin&gt;&gt;n&gt;&gt;V;    for(int i = 1; i &lt;= V;i++) cin&gt;&gt;v[i]&gt;&gt;w[i];   //将每个物品的体积和价值存储        //for(int x = 0; x &lt;= V; x++) dp[n+1][x] = 0; //状态初始化，全局数组每个初始值都为0所有可以不必初始化        for(int i = n;i&gt;=1;i--)&#123;        for(int j = 0;j&lt;=V;j++)&#123;            if(j&gt;=v[i])&#123;                dp[i][j] = max(dp[i+1][j],dp[i+1][j-v[i]]+w[i]);            &#125;else&#123;                dp[i][j] = dp[i+1][j];            &#125;        &#125;    &#125;    int m = V;    for(int i = 1;i&lt;=n;i++)&#123;        //当n&lt;v[i]时肯定该状态是通过没有选i物品转移得到的        //样例说明，当枚举到第2个物品时，首先看当前背包最大体积是否可能放第2个物品，如果可以，进一步判断当前背包dp[i][m]是否放了第2个物品        //如果是放入了的情况，那么背包这时候的价值就等于拿出第2个物品后的背包的价值加上物品2的价值(可能是废话)，哈哈哈        if(m&gt;=v[i] &amp;&amp; dp[i][m] == dp[i+1][m-v[i]]+w[i])&#123;            cout&lt;&lt;i&lt;&lt;&quot; &quot;;            m-=v[i];        &#125;    &#125;    return 0;&#125;\n","categories":["数据结构与算法"],"tags":["数据和结构与算法","背包","DP","打卡"]},{"title":"重庆邮电大学考研经验","url":"/2024/04/e227d6720297.html","content":"各科复习规划数学数学这一门学科特别重要，一道选择题等于五个英语完形填空。并且数学的区分度很高。\n总体时间安排\n无论是一轮复习、二轮复习、三轮复习，都是雷打不动一早上学习时间，英语好的同学甚至可以牺牲一部分英语时间去搞数学。  \n阶段\n第一阶段（ 现在 - 7 月 中旬）：完成数学基础学习，数学基础很重要。建议形成自己的知识体系，按照看课 - 总结 - 写题 - 反思 - 总结。  \n第二阶段（ 7 月 中旬 - 10月中旬 ）： 完成数学强化学习，写强化习题，继续完善自己的知识体系，按照看课 - 总结 - 写题 - 反思 - 总结。  \n真题阶段（ 10 月中旬 - 11 月中旬 ）： 完成真题，研究每道题的考点，在自己总结的知识体系上去找，这道题考察的什么点，自己哪里没有想到。  \n模拟题阶段（ 11 月中旬 - 考前 ）：  写模拟卷根据做的情况查漏补缺。  \n课程和老师推荐\n张宇老师的课幽默风趣，讲解的知识点通俗易懂，总结的结论也很实用。  \n个人建议\n平时注意细节，每一个知识点都要搞懂，写题时的模糊点一定要弄懂，然后总结到自己的笔记上（形成自己的知识体系）。数学一定要重视计算，真题计算量大，一定要多算。  \n英语相比于数学来说，英语的复习还是比较简单的。  \n本人中考英语 35，高考英语 100，四级考了 5 次（最后凭借考研的词汇量过的四级，当时报了六级，由于在家备考没去考），英语语法基础为 0。  但是最终考研英语 77。  \n阶段\n将整个复习拆分为单词部分、语法部分和真题部分。\n（1）单词部分\n背考纲词汇阶段（ 现在 - 10 月中旬 ）：使用不背单词APP在每天早上起床以及中午睡觉前以及下午背新单词，复习旧单词。我当时背单词特别痛苦，背单词要花费接近两个小时。\n反复刷高 - 中 - 低频词阶段（ 10 月中旬 - 考前 ）：使用不背单词APP自行抽时间，每天新复习 150 个单词，再复习前一天记的 150 个单词，这个阶段背单词就会比较快了，基本上12天就可以完成一轮，因为高 - 中 - 低频词只有 1800 个左右。\n（2）语法部分（ 7 月之前）\n一个月看完田静老师的句句真研语法课，跟着静姐公众号写每日一句（ 我没坚持下来每天写 ）。看完后，单词刷到偶考词左右就可以开启真题了。\n（3）真题部分\n真题十分重要，建议留 3 年真题模拟考试，其他的真题拆分来写，每天写一篇。\n阶段 1（7 月 - 9 月）：写完所有阅读。定时写完一篇阅读，写完后精读，记忆不会的单词，搞懂文章中的长难句。\n阶段 2（9 月 - 11 月）：先学习新题型的技巧，然后每天二刷一篇真题阅读再配套写一篇新题型，同样要定时，写完后精读。\n阶段 3（11 月 - 考前）：建议学习 monkey 老师的作文写作方法，然后背模板，写真题的作文，每天也要保持写一篇真题阅读或者新题型。考前几周，可以把留下的 3 套真题进行模考，然后精读。\n课程和老师推荐\n\n单词软件推荐不背单词APP。\n语法课推荐田静老师的句句真研和对应课本。\n阅读看看唐迟老师的阅读的逻辑（单词量上去了感觉技巧没啥用）。\n新题型随意选老师。\n作文非常推荐 monkey 老师，用最少的时间尽量拿高分，英语差生的福音！\n\n个人建议\n英语一定要注重基础，词汇量和语法长难句。词汇量又是重中之重，词汇量上去了相信英语 70 分并不难。\n政治政治复习非常简单，看徐涛强化课 + 刷选择题 + 背肖四大题 &#x3D; 政治 75。因为我背功太差，肖四只背了两套，但是还是建议全背。政治考的还可以主要是因为我选择题写的好，得了 39 分（ 满分 50 ），所以刷选择题还是很重要的。\n总体时间安排\n政治我从 8 月份才开始，每天只花一个半小时左右看政治课程，然后刷题。但在最后一个月，我压缩了计算机网络和英语的复习时间都给政治，去刷选择题。最后十多天压缩了很多时间来背肖四。\n阶段\n阶段 1 （8 月 - 9 月）：看徐涛强化课，看完一节刷对应的肖 1000 选择题。\n阶段 2 （9 月 - 肖八出版）：二刷肖 1000 选择题，刷肖八选择题。\n阶段 3 （肖四出版 - 考前）：二刷肖八选择题 + 刷肖四选择题 + 背肖四大题。\n课程和老师推荐\n\n政治的课程认准徐涛强化就行了，徐涛老师的课真的很有意思，买本徐涛老师的核心考案勾勾画画就行了。\n后期可以和研友拼一个选择题刷题小程序刷选择题，我用的是苍盾考研。\n肖八肖四人手一本。\n\n个人建议\n政治属于前期轻松，后期发力的学科，我一般在下午饭后点开徐涛老师的课来看，看完写题非常愉快。政治的选这题特别重要，马原选择题一定要搞懂对应的知识点，其他帽子题多刷几次就记住了。\n专业课从今年情况来看，重邮 803 计算机网络的难度再次加大。尽量早点开始准备专业课，我是从重邮出大纲（ 2023 年 7 月 21 日 ）后才开始准备的计算机网络，并且每天花费的时间也不是特别多，最多 3 小时，最终计算机网络成绩还不错，在准备计算机网络时，第一章和最后三章不用花太多时间去准备。\n对比我的数学，花费了很多时间，但是结果不尽人意，所以学习不是一味的堆积时间，掌握方法还是很重要。后来我也反思了自己的学习方法和考试策略，前面的经验分享，就是我结合自己的经验和反思后给出的。\n我当初的计划\n每天学习 3 小时。\n第一阶段（7 月底 - 8 月底）：看 bilibili 湖科大的课程，每看完一节课啃谢希仁计算机网络对应的章节再总结到自己的知识体系中。\n第二阶段（8 月底 - 11 月初）：更仔细的看谢希仁计算机网络，完善知识体系，看完一章写课后习题，先按照自己的想法去写，然后对答案，理解后关上答案再写一遍。\n第三阶段（11 月初 - 12 月初）：写真题，然后看对应考点，结合书和自己的知识体系。\n第四阶段（12 月初 - 考前）：结合书看自己的知识体系，理解记忆，去思考会怎样考，还可以写写 408 计算机网络的题。\n建议的计划\n考虑到计算机网络难度加大，提早准备，多写题多看书有很大的优势。\n第一阶段（现在 - 6 月初）：看 bilibili 湖科大的课程，每看完一节课啃谢希仁计算机网络对应的章节再总结到自己的知识结构中。\n第二阶段（6 月 - 8 月）：更加仔细的看谢希仁计算机网络，写课后习题并完善知识体系。\n第三阶段（8 月 - 11 月）：看计算机网络黑皮书，写对应的课后习题。\n第四阶段（11 月 - 12 月）：写真题，然后看对应考点，结合书和自己的知识体系。\n第五阶段（12 月 - 考前）：结合书看自己的知识体系，理解记忆，还可以写写 408 计算机网络的题。\n课程和老师推荐\n\n湖科大的计算机网络课程。\n谢希仁的计算机网络和配套的计算机网络释疑与习题解答。\n计算机网络黑皮书。\n\n个人建议\n计算机网络的第一章和最后三章不用花大量时间。重要的是中间的五层体系结构，一定要搞懂每层每个协议，以及协议和协议之间的关系。要将每一层的知识点串起来，每个协议不是孤立的，学到上层协议要多想想相关联的下层协议。\n虽然计算机网络重邮压分严重，考题也考的比较难，但只要静下心来把各种协议搞懂了，其实也不会太差。\n","categories":["杂文"],"tags":["考研"]},{"title":"CodeforcesRound791(Div2)","url":"/2022/05/fa03b3b7bd99.html","content":"\n题目来源https://codeforces.com/contest/1679\n\n第一题题意有两种类型的车：两轴车，三轴车。一个轴能连接两个轮胎，题目给n个轮胎，计算最少可以组成多少辆车，最多可以组成多少辆车。如果给的n不能组成输出-1\n思路无论是两轴还是三轴车，由于每个轴只能连接2个轮胎，所以轮胎必然是偶数，奇数必然不满足要求。首先将轮胎转换成轴数，即轴数&#x3D;n&#x2F;2。对于最大值，我们尽量先组二轴车,剩下的轴数可能为0或者为1，如果为0则代表刚好可以全部组成2轴车，如果为1则可以拆一辆二轴车组成三轴车对于最小值，我们尽量先组成三轴车，剩下的轴数可能为0,1,2，如果为0则刚好组成，为1则拆一辆三轴组成两辆二轴车，如果为2则自行组成一辆二轴车。注：轮胎数小于等于4时要特殊考虑，当n等于4计算出来的结果恰好符合答案，所以不用单独考虑。当n小于4时也是无法组成任何一种车所以输出-1\n代码#include &lt;iostream&gt;using namespace std;int main()&#123;    int t;    cin&gt;&gt;t;    while(t--)&#123;        long long n;        cin&gt;&gt;n;        if(n%2 !=0 || n&lt; 4)&#123;            cout&lt;&lt;-1&lt;&lt;endl;        &#125;else&#123;            long long minans = 0;             long long maxans = 0;            n/=2;            //轴数n;            if(n%2 == 1)&#123;                maxans = n/2-1+1;            &#125;else&#123;                maxans = n/2;            &#125;            if(n%3 == 1)&#123;                minans = n/3-1+2;            &#125;else if(n%3 == 2)&#123;                minans = n/3+1;            &#125;else&#123;                minans = n/3;            &#125;            cout&lt;&lt;minans&lt;&lt;&quot; &quot;&lt;&lt;maxans&lt;&lt;endl;        &#125;    &#125;    return 0;&#125;\n第二题题意给一个包含n个数的数组，对数组执行q次操作。操作分为两种类型：\n\n将数组中第i个元素改为x\n将数组中所有元素改为x\n\n每一次操作后输出数组的和。\n思路最暴力的方法是：\n\n对于每一个操作都更新数组中的数(操作1是O(1)的操作2是O(N))\n对数组求和(O(N))\n\n一共有n次操作所以必然超时。在此方法上对求和步骤进行优化：\n\n保留上次操作的sum(和)。\n对于操作1，新的sum只需要加上第_i位本次要修改的值减去_上次修改后的值。\n对于操作2，新的sum是n*x。\n\n优化更新操作：操作2更新整个数组的值必然会造成超时，所以我们优化一下只需要记录操作2执行了count次，保存整个数组要修改的值x，以及记录数组每个元素执行了多少次操作2。当操作1要查询上次修改后的值来更新sum时，先查询i元素执行了几次操作2和count进行比较，如果相等说明i元素已经进行了最新次的操作2那么该元素所存的值就是我们想要的值，因此直接按照操作1的求和来更新sum，如果不相等说明i元素未进行最新次的操作2，那么它上次操作后的值为最新次操作2所修改的值x，用x按照操作1的求和更新sum。整个操作1结束后更新 i位的值。优化后为O(N)\n代码#include &lt;iostream&gt;#include &lt;map&gt;using namespace std;const int N = 200005;long long nums[N];map&lt;int ,int&gt; m;long long now_cnt;long long now[N];int main()&#123;    int n,q;    cin&gt;&gt;n&gt;&gt;q;    long long sum = 0;    for(int i = 1; i&lt;= n;i++)&#123;        cin&gt;&gt;nums[i];        sum+=nums[i];    &#125;        for(int i = 0;i&lt;q;i++)&#123;                long long a,b,c;        cin&gt;&gt;a;        if(a == 1)&#123;            cin&gt;&gt;b&gt;&gt;c;            if(now_cnt == m[b])&#123;                sum+=c-nums[b];            &#125;else&#123;                sum+=c-now[now_cnt];            &#125;            nums[b] = c;            m[b] = now_cnt;        &#125;else&#123;            cin&gt;&gt;b;            now_cnt++;            now[now_cnt] = b;            sum = n*b;        &#125;        cout&lt;&lt;sum&lt;&lt;endl;    &#125;        return 0;&#125;\n第三题题意思路代码第四题题意思路代码第五题题意思路代码第六题题意思路代码","categories":["数据结构与算法","刷题记录"],"tags":["数据结构与算法"]},{"title":"Codeforces Round","url":"/2022/05/9ddeb4839bab.html","content":"\n题目来源https://codeforces.com/contest/1676\n\n第一题题意给一个6位的数，如果后三位数的和等于前三位数的和则输出YES反之输出NO\n思路将数后三位累加前三位累减，最后判断是否为0\n代码#include &lt;iostream&gt;using namespace std;int main()&#123;    int n;    cin&gt;&gt;n;    int cnt = 0;    for(int i = 0;i&lt;n;i++)&#123;        int b;        int sum = 0;        int cnt = 0;        cin&gt;&gt;b;        while(b)&#123;            int temp = b%10;            b/=10;            if(cnt &gt;= 3)&#123;                sum-=temp;            &#125;else&#123;                sum+=temp;            &#125;            cnt++;        &#125;        if(sum == 0) cout&lt;&lt;&quot;YES&quot;&lt;&lt;endl;        else cout&lt;&lt;&quot;NO&quot;&lt;&lt;endl;    &#125;    return 0;&#125;\n第二题题意有n个盒子，每个盒子有一定的糖果，让你吃每个盒子里的糖果使所有盒子中的糖果变成一样的，输出吃了多少个糖果\n思路找出糖果最少的盒子，让每个盒子的糖果数量与最小的糖果数相减并累加起来就是结果。\n代码#include &lt;iostream&gt;using namespace std;int num[55];int main()&#123;    int t;    cin&gt;&gt;t;    while(t--)&#123;        int n;        cin&gt;&gt;n;        int minnum = 0x3f3f3f3f;        for(int i = 0;i&lt;n;i++)&#123;            cin&gt;&gt;num[i];            minnum = min(minnum,num[i]);        &#125;        int sum = 0;        for(int i = 0;i&lt;n;i++)&#123;            sum+=(num[i]-minnum);        &#125;        cout&lt;&lt;sum&lt;&lt;endl;    &#125;    return 0;&#125;\n第三题题意给n个单词，每个单词的长度为m,找出两个单词使他们满足变成相同的单词所需要的操作次数最小，操作是指单词的每一个字符例如a通过一次操作可以变为b，b通过3次操作变成e。best-&gt;cost,也就是b-&gt;c,e-&gt;o,s-&gt;s,t-&gt;t的操作次数的和。\n思路由于数据量比较小，直接暴力模拟，判断每个单词和其他单词每一位所需要的操作次数，记录最小操作数最后输出即可\n代码#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;using namespace std;int nums[55][55];string strs[55];int main()&#123;    int t;    cin&gt;&gt;t;    while(t--)&#123;        int n,m;        int ans = 0x3f3f3f3f;        cin&gt;&gt;n&gt;&gt;m;        for(int i = 0;i&lt;n;i++) cin&gt;&gt;strs[i];                for(int i = 0;i&lt;n;i++)&#123;            for(int j = i+1;j&lt;n;j++)&#123;                int sum = 0;                for(int k = 0;k&lt;m;k++)&#123;                    sum += max(strs[i][k],strs[j][k])-min(strs[i][k],strs[j][k]);                 &#125;                ans = min(ans,sum);            &#125;        &#125;               cout&lt;&lt;ans&lt;&lt;endl;    &#125;    return 0;&#125;\n第四题题意给一个n*m的矩阵，找到某一个位置的值加上斜对角的其他所有值以及反对角的其他所有值的总和最大\n思路对角线可以看做是y&#x3D;x+b的一条直线，反对角线可以看做是y&#x3D;-x+b的直线，可以看出每一个b都确定一条直线，确定对角线的b&#x3D;y-x,反对角线的b&#x3D;y+x，读数的时候维护对角线的和以及反对角线的和，由于y-x可能为负数，我们是用数组来存储的所以需要对整个对角线的b进行偏移，偏移量为n，最后遍历整个矩阵，计算每个位置对角线数和[y-x+n]+反对角数和[x+y]-该位置的值[x][y]，然后选出最大值。\n代码#include &lt;iostream&gt;#include &lt;cstring&gt;using namespace std;const int N = 210;int nums[N][N];int dg[2*N],udg[2*N];int dp[N][N];int main()&#123;    int t;    cin&gt;&gt;t;    while(t--)&#123;        int n,m;        memset(dg,0,sizeof dg);        memset(udg,0,sizeof udg);        cin&gt;&gt;n&gt;&gt;m;        for(int i = 0;i&lt;n;i++)&#123;            for(int j = 0;j&lt;m;j++)&#123;                cin&gt;&gt;nums[i][j];                dg[j-i+n]+=nums[i][j];                udg[i+j]+=nums[i][j];            &#125;        &#125;        int ans = 0;        for(int i = 0;i&lt;n;i++)&#123;            for(int j = 0;j&lt;m;j++)&#123;                dp[i][j] = dg[j-i+n]+udg[i+j]-nums[i][j];                ans = max(ans,dp[i][j]);            &#125;        &#125;        cout&lt;&lt;ans&lt;&lt;endl;    &#125;&#125;\n第五题题意给n个糖果，每个糖果有一定的甜度值，吃糖果可以获得甜度值。然后是q次询问，对于每一次询问，给一个待满足甜度值x，判断目前的糖果是否能够满足该甜度值，如果不能输出-1，如果能输出最少需要吃多少颗糖果。\n思路贪心+二分我们尽量吃甜度值大的糖果，如果吃了还未满足又吃第二大的糖果，这样的结果总是最优的。因此我们可以对所以糖果甜度值按照从大到小排序，然后求前缀合，前缀和数组s满足贪心的思路。接下来就是在s数组中从1-n依次查询,第一个大于或等于待满足甜度值的下标，该下标表示要吃多少颗糖果，也就是答案。但是这道题数据量可能会超时所以采用二分查找。注:对于所有糖果一起吃都无法满足的询问直接输出-1，\n代码#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;using namespace std;typedef long long LL;const int N = 300005;int n,m;LL nums[N],s[N];bool cmp(LL a,LL b)&#123;    return a&gt;b;&#125;int find(int a)&#123;    int l = 1,r = n;        while(l&lt;r)&#123;        int mid = l+r&gt;&gt;1;        if(s[mid] &lt; a)&#123;            l = mid+1;        &#125;else&#123;            r = mid;        &#125;    &#125;        return l;&#125;int main()&#123;    int t;    cin&gt;&gt;t;    while(t--)&#123;        memset(nums,0,sizeof nums);        memset(s,0,sizeof s);        cin&gt;&gt;n&gt;&gt;m;        for(int i = 1;i&lt;=n;i++)&#123;            cin&gt;&gt;nums[i];        &#125;        sort(nums+1,nums+n+1,cmp);              cout&lt;&lt;endl;        for(int i = 1;i&lt;=n;i++)&#123;            s[i] = s[i-1]+nums[i];        &#125;                cout&lt;&lt;endl;        while(m--)&#123;            int temp;            cin&gt;&gt;temp;            if(temp&gt;s[n])                 cout&lt;&lt;-1&lt;&lt;endl;            else                cout&lt;&lt;find(temp)&lt;&lt;endl;        &#125;    &#125;    return 0;&#125;\n第六题题意给一个数组，包含n个数，给一个k，寻找一段连续的序列，使得序列中的每一个数都在数组中至少出现k次。序列的左右边界l,r满足l&lt;&#x3D;r，比如1-3的序列就包含了123三个数，1-1包含了1一个数\n思路map结构存储+双指针map底层使用的红黑树，会默认按照key进行排序。我们key存储的是数组中出现的数，value存储该数出现的次数。然后对整个map进行遍历，用l,len用于记录当前访问的一个序列，用ans_l,ans_len存储全局最长的序列。(r-l &#x3D; len-1所以可以得到r &#x3D; len-1+r)。初始化len为-1，r指针遍历map的每一个元素，如果r元素出现的次数满足题目要求，则进一步判断该元素是否可以直接加入上次的序列，可以则更新l和len的长度，反之则说明中间某些元素不满足，更新序列 r为当前元素,len为1。每次遍历后都更新全局最优序列，如果l当前序列en比全局最优的更优才进行更新。\n代码#include &lt;iostream&gt;#include &lt;map&gt;using namespace std;int main()&#123;    int t;    cin&gt;&gt;t;    while(t--)&#123;        map&lt;int,int&gt; m;        int n,k;        cin&gt;&gt;n&gt;&gt;k;        int big = 0;        for(int i = 0;i&lt;n;i++)&#123;            int id;            cin&gt;&gt;id;            if(!m.count(id))&#123;                m.insert(&#123;id,1&#125;);            &#125;else&#123;                m[id] = m[id]+1;            &#125;        &#125;        int len = -1;        int ans_len = -1;        int ans_l = -1;        int l,r;         for(auto iter = m.begin();iter != m.end();iter++)&#123;            r = iter-&gt;first;            if(iter-&gt;second &gt;= k)&#123;                if(len == -1)&#123;                    l = r;                    len = 1;                &#125;else if(len-1+l == iter-&gt;first-1)&#123;                    len++;                &#125;else&#123;                    l = r;                    len = 1;                &#125;                if(len&gt;ans_len)&#123;                    ans_len = len;                    ans_l = l;                &#125;            &#125;        &#125;        if(ans_len == -1) cout&lt;&lt;-1&lt;&lt;endl;        else             cout&lt;&lt;ans_l&lt;&lt;&quot; &quot;&lt;&lt;ans_len-1+ans_l&lt;&lt;endl;    &#125;    return 0;&#125;\n","categories":["数据结构与算法","刷题记录"],"tags":["数据结构与算法"]},{"title":"bfs-献给阿尔吉侬的花束","url":"/2021/11/8ed9a65746b9.html","content":"题目来源www.acwing.com/problem/content/1103/\n\n题目阿尔吉侬是一只聪明又慵懒的小白鼠，它最擅长的就是走各种各样的迷宫。\n今天它要挑战一个非常大的迷宫，研究员们为了鼓励阿尔吉侬尽快到达终点，就在终点放了一块阿尔吉侬最喜欢的奶酪。\n现在研究员们想知道，如果阿尔吉侬足够聪明，它最少需要多少时间就能吃到奶酪。\n迷宫用一个 R×C 的字符矩阵来表示。\n字符 S 表示阿尔吉侬所在的位置，字符 E 表示奶酪所在的位置，字符 # 表示墙壁，字符 . 表示可以通行。\n阿尔吉侬在 1 个单位时间内可以从当前的位置走到它上下左右四个方向上的任意一个位置，但不能走出地图边界。\n输入格式第一行是一个正整数 T，表示一共有 T 组数据。\n每一组数据的第一行包含了两个用空格分开的正整数 R 和 C，表示地图是一个 R×C 的矩阵。\n接下来的 R 行描述了地图的具体内容，每一行包含了 C 个字符。字符含义如题目描述中所述。保证有且仅有一个 S 和 E。\n输出格式对于每一组数据，输出阿尔吉侬吃到奶酪的最少单位时间。\n若阿尔吉侬无法吃到奶酪，则输出“oop!”（只输出引号里面的内容，不输出引号）。\n每组数据的输出结果占一行。\n数据范围1&lt;T≤10,\n2≤R,C≤200\n输入样例：33 4.S..###...E.3 4.S...E......3 4.S..####..E.\n\n输出样例：51oop!\n\nAC代码#include &lt;iostream&gt;#include &lt;queue&gt;#include &lt;cstring&gt;using namespace std;#define x first#define y secondtypedef pair&lt;int,int&gt; PII;const int MAX = 202;char map[MAX][MAX]; //地图数组int dis[MAX][MAX];  //距离数组int max_x,max_y;    //x最大值，y最大值int moving[4][2] = &#123;&#123;0,1&#125;,&#123;0,-1&#125;,&#123;1,0&#125;,&#123;-1,0&#125;&#125;; //偏移量bool isTrue(PII loc)&#123;    //判断是否越界是否为墙    return loc.x &gt;= 0 &amp;&amp; loc.x &lt; max_x &amp;&amp; loc.y &gt;= 0 &amp;&amp; loc.y &lt;max_y &amp;&amp; map[loc.x][loc.y] != &#x27;#&#x27;;&#125;//宽搜-bfs//bfs算法类似于层次遍历算法，将遍历过的位置用数组记录，防止重复遍历void bfs(PII start)&#123;\tmap[start.x][start.y] = &#x27;#&#x27;;    //先将起始位置设为已经访问    queue&lt;PII&gt; q;                   //层次遍历需要用到数组    q.push(start);                  //先将起始节点加入队列            while(!q.empty())&#123;        PII now = q.front();        //取出队头，为当前所在节点        PII next;                   //当前节点子节点        q.pop();                    //将当前对头出队               //遍历上下左右四个方向        for(int i = 0; i &lt; 4; i++)&#123;            next.x = now.x + moving[i][0];            next.y = now.y + moving[i][1];                        if(isTrue(next))&#123;//判断子节点是否符合要求                                if(map[next.x][next.y] == &#x27;.&#x27;)&#123;                    q.push(next);//符合要求就将子节点入队                    dis[next.x][next.y] = dis[now.x][now.y] + 1;//记录子节点层次                    map[next.x][next.y] = &#x27;#&#x27;;//记录子节点已经访问                &#125;              \tif(map[next.x][next.y] == &#x27;E&#x27;)&#123;            \t    //如果子节点为出口则输出结果                    cout&lt;&lt;dis[now.x][now.y]+1&lt;&lt;endl;                    return;                &#125;             &#125;       &#125;    &#125;    cout&lt;&lt;&quot;oop!&quot;&lt;&lt;endl;&#125;int main()&#123;    int n;    cin&gt;&gt;n;    int i = 0;    while(n--)&#123;        memset(map, &#x27;#&#x27;, sizeof(map));        memset(dis, 0, sizeof(dis));        PII start;        cin&gt;&gt;max_x&gt;&gt;max_y;        for(int i = 0; i &lt; max_x; i++)            cin&gt;&gt;map[i];        for(int i = 0; i &lt; max_x; i++)&#123;            for(int j = 0; j &lt; max_y; j++)&#123;                if(map[i][j] == &#x27;S&#x27;)&#123;                    start.x = i;                    start.y = j;                &#125;            &#125;        &#125;        bfs(start);    &#125;    return 0;&#125;\n","categories":["数据结构与算法","刷题记录"],"tags":["数据和结构与算法","打卡","bfs"]},{"title":"交换瓶子","url":"/2021/11/e35993db4acf.html","content":"题目来源https://www.acwing.com/problem/content/1226/\n\n题目有 N 个瓶子，编号 1∼N，放在架子上。\n比如有 5 个瓶子：\n2 1 3 5 4\n\n要求每次拿起 2 个瓶子，交换它们的位置。\n经过若干次后，使得瓶子的序号为：\n1 2 3 4 5\n\n对于这么简单的情况，显然，至少需要交换 2 次就可以复位。\n如果瓶子更多呢？你可以通过编程来解决。\n输入格式第一行包含一个整数 N，表示瓶子数量。\n第二行包含 N 个整数，表示瓶子目前的排列状况。\n输出格式输出一个正整数，表示至少交换多少次，才能完成排序。\n数据范围1≤N≤10000\n输入样例153 1 2 5 4\n\n输出样例13\n\n输入样例255 4 3 2 1\n\n输出样例22\n\nAC代码贪心\n用贪心的思想：\n\n\n根据题意可知，所给一个N，那么就必然包含1-n这n个数字，还要求递增，因此其数字应该与下标对应（下标0不存储数据），意思就是数字1必须在1这个下标位置，数字2必须在2这个下标位置，所以我们直接对元素互换。互换次数就是所求答案\n\n\n样例分析：\n\n\n3，1，2，5，4 第一个数字是3，它本应该在下标为3的位置，但是却在下标为1这个位置，无论我们怎么交换，数字3最终会在3这个位置，最终结果一样，我们怎样保证最少次交换次数让其在它本应该在的位置呢？显然我们直接将3放在下标3的位置，与原来下标3位置的元素进行交换即可，所以3和2交换，第一位是2，2又和1交换，现在数组变成1，2，3，5，4，我们继续遍历到5，然后5和4进行交换。总交换次数3\n\n#include &lt;iostream&gt;using namespace std;const int MAX = 10004;int main()&#123;    int n,res = 0;    int num[MAX];    cin&gt;&gt;n;    for(int i = 1; i &lt;= n; i++) cin&gt;&gt;num[i];    //枚举如果第i位的值是否在其所在位置    for(int i = 1; i &lt;= n; i++)&#123;        int temp;        while(num[i] != i)&#123;            //不在就交换位置            temp = num[i];            num[i] = num[temp];            num[temp] = temp;            res++;        &#125;    &#125;    cout&lt;&lt;res&lt;&lt;endl;    return 0;&#125;\n\n图\n可以将数组转换成图，我们把以交换顺序为边作图（上面那种方法分析了实际上就是数字应该与其下标对应，所以是3就要和下标为3的元素互换），直接样例分析：3，1，2，5，4：3-&gt;2-&gt;1&gt;3这是一个环，5-&gt;4-&gt;5这是一个环。我们最终要将数组搞成升序也就是：1，2，3，4，5，转换为图其实就是1-&gt;1,2-&gt;2,3-&gt;3,4-&gt;4,5-&gt;5。也就是从上面2个环转换成5个自环。对于一个环（3，1，2），我们任意交换一对（1，2）线性结果为3，2，1，环为3–&gt;1-&gt;3,2-&gt;2.1个环裂成了2个环，再交换一次3-&gt;1-&gt;3这个环，又分一个环出来，最终（3，1，2）这个三个元素组成的环操作两次变成全自环。对于（5，4）这两个元素组成的环，交换一次即可。对于一个环，有3个元素，操作2次，有2个元素操作1次。综合来说对于两个环，有3+2五个元素，操作了2+1次，5个元素操作了3次，多举几个例子就可以得到，元素数量-操作次数&#x3D;环数，所以，元素数量-环数 &#x3D;操作次数，因此我们只需要看有多少个环就行\n\n#include &lt;iostream&gt;using namespace std;const int MAX = 10004;bool v[MAX];//记录是否遍历过int num[MAX];int main()&#123;    int n,res = 0;    cin&gt;&gt;n;    for(int i = 1; i &lt;= n; i++) cin&gt;&gt;num[i];        for(int i = 1; i &lt;= n; i++)&#123;        if(!v[num[i]])&#123;\t//如果第i个位置的数组没有遍历则就是一个新环            res++;//环数++            for(int j = num[i]; !v[j]; j = num[j])&#123;                v[j] = true;\t//循环遍历，遍历的元素设为t            &#125;        &#125;    &#125;    cout&lt;&lt;n-res&lt;&lt;endl;    return 0;&#125;\n","categories":["数据结构与算法","刷题记录"],"tags":["数据和结构与算法","打卡"]},{"title":"优先队列-负载均衡","url":"/2021/11/f71cbcac6047.html","content":"\n题目用到了优先队列的一些操作，如果知道操作就比较简单了，所以有必要记录一下。\n\n题目来源www.acwing.com/problem/content/3495/\n\n题目有 n 台计算机，第 i 台计算机的运算能力为$ v_i$。\n有一系列的任务被指派到各个计算机上，第 i 个任务在 $a_i$ 时刻分配，指定计算机编号为 $b_i$，耗时为 $c_i$ 且算力消耗为 $d_i$。\n如果此任务成功分配，将立刻开始运行，期间持续占用 bi 号计算机 $d_i$ 的算力，持续 $c_i$ 秒。\n对于每次任务分配，如果计算机剩余的运算能力不足则输出 −1，并取消这次分配，否则输出分配完这个任务后这台计算机的剩余运算能力。\n\n输入格式输入的第一行包含两个整数 n,m，分别表示计算机数目和要分配的任务数。\n第二行包含 n 个整数$ v_1,v_2,⋅⋅⋅v_n$，分别表示每个计算机的运算能力。\n接下来 m 行每行 4 个整数 $a_i,b_i,c_i,d_i$，意义如上所述。数据保证 $a_i$ 严格递增，即 $a_i&lt;a_i+1$。\n\n输出格式输出 m 行，每行包含一个数，对应每次任务分配的结果。\n\n数据范围对于 20% 的评测用例，$n,m≤200$。\n对于 40% 的评测用例，$n,m≤2000$。\n对于所有评测用例，$1≤n,m≤200000，$$1≤a_i,c_i,d_i,v_i≤10^9$，$1≤b_i≤n$。\n\n输入样例：5 51 1 5 32 2 2 63 1 2 34 1 6 15 1 3 36 1 3 4\n\n\n输出样例：2-1-11-10\n\n\n样例解释时刻 1，第 1 个任务被分配到第 1 台计算机，耗时为 5，这个任务时刻 6 会结束，占用计算机 1 的算力 3。\n时刻 2，第 2 个任务需要的算力不足，所以分配失败了。\n时刻 3，第 1 个计算机仍然正在计算第 1 个任务，剩余算力不足 3，所以失败。\n时刻 4，第 1 个计算机仍然正在计算第 1 个任务，但剩余算力足够，分配后剩余算力 1。\n时刻 5，第 1 个计算机仍然正在计算第 1,4 个任务，剩余算力不足 4，失败。\n时刻 6，第 1 个计算机仍然正在计算第 4 个任务，剩余算力足够，且恰好用完。\n\nAC代码#include &lt;iostream&gt;#include &lt;queue&gt;using namespace std;const int MAX = 200005;typedef pair&lt;int,int&gt; PII;  //加入的工作，存储形式为&lt;结束时刻，算力&gt;，前一个参数存放结束时刻，后一个参数存放占用的算力int computer[MAX];          //维护一个电脑算力数组priority_queue&lt;PII,vector&lt;PII&gt;,greater&lt;PII&gt;&gt; pq[MAX];//优先队列数组，为每个电脑目标创建一个优先队列存取加入的PII类型的工作int main()&#123;    int n,m;    cin&gt;&gt;n&gt;&gt;m;    for(int i = 1; i &lt;= n; i++) &#123;        cin&gt;&gt;computer[i];    &#125;    int a,aim,usetime,usev; //时刻，目标，消耗时间，消耗算力    while(m--) &#123;        cin&gt;&gt;a&gt;&gt;aim&gt;&gt;usetime&gt;&gt;usev;        //循环处理该目标电脑的工作，如果工作结束时间&lt;=该时刻则恢复算力清除这一工作        while(pq[aim].size() &amp;&amp; (pq[aim].top().first &lt;= a))&#123;            computer[aim]+=pq[aim].top().second;//恢复算力            pq[aim].pop();//弹出任务        &#125;        //处理完后，判断当前安排的工作是否还可以执行        if(computer[aim] &gt;= usev)&#123;            pq[aim].push(&#123;a+usetime,usev&#125;);//加入任务            computer[aim]-=usev;//更新算力            cout&lt;&lt;computer[aim]&lt;&lt;endl;        &#125;else&#123;            cout&lt;&lt;-1&lt;&lt;endl;        &#125;    &#125;    return 0;&#125;\n\n优先队列\n优先队列虽然称为队列，但其底层实现原理是基于堆的设计思想，还没详细学，这里先粗略的记录下基础操作，之后学了再更新\n\n\n所在库:queue\n\n操作和队列相似\n\nc++中的定义 priority_queue&lt; 数据类型，容器(vector&lt;&gt;),排序方式(greater&lt;&gt;,less&lt;&gt;)&gt;\n\ngreater&lt;&gt;大顶堆-降序\nless&lt;&gt;小顶堆-升序\n\n\n\n","categories":["数据结构与算法","刷题记录"],"tags":["数据和结构与算法","打卡","优先队列","堆"]},{"title":"分解质因数-求完全平方数","url":"/2021/11/ab2bbf7325e0.html","content":"题目来源www.acwing.com/problem/content/3493/\n\n题目一个整数 a 是一个完全平方数，是指它是某一个整数的平方，即存在一个整数 b，使得$ a&#x3D;b^ 2$\n给定一个正整数 n，请找到最小的正整数 x，使得它们的乘积是一个完全平方数。\n\n输入格式输入一行包含一个正整数 n。\n\n输出格式输出找到的最小的正整数 x。\n\n数据范围对于 30% 的评测用例，$1≤n≤1000$，答案不超过 $1000$。\n对于 60% 的评测用例，$1≤n≤10^8$，答案不超过 $10^8$。\n对于所有评测用例，$1≤n≤10^{12}$，答案不超过 $10^{12}$。\n\n输入样例112\n\n\n输出样例13\n\n\n输入样例215\n\n\n输出样例215\n\n\nAC代码\n用到了分解质因数操作还是有必要记录以下，说一下题目思路。以样例分析，样例给的12求一个数乘以12是完全平方数，我们把12进行分解$32^2&#x3D;12$ ，我们只需要补一个质因数3就可以变成完全平方数$3^22^2&#x3D;36$了\n\n#include &lt;iostream&gt;using namespace std;typedef long long LL;int main()&#123;    LL n;    cin&gt;&gt;n;    LL res = 1;    //分解质因数    for(LL i = 2;i*i&lt;=n;i++)&#123;        int s = 0;        while(n%i == 0)&#123;            s++;            n/=i;        &#125;        if(s%2) res*=i;    &#125;    if(n&gt;1) res*=n;    cout&lt;&lt;res&lt;&lt;endl;    return 0;&#125;\n\n\n","categories":["数据结构与算法","刷题记录"],"tags":["数据和结构与算法","打卡"]},{"title":"反转链表","url":"/2021/11/b66198f70862.html","content":"题目来源www.acwing.com/problem/content/33/\n题目定义一个函数，输入一个链表的头结点，反转该链表并输出反转后链表的头结点。\n思考题请同时实现迭代版本和递归版本。\n样例输入:1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL输出:5-&gt;4-&gt;3-&gt;2-&gt;1-&gt;NULL\n\n\nAC代码/** * Definition for singly-linked list. * struct ListNode &#123; *     int val; *     ListNode *next; *     ListNode(int x) : val(x), next(NULL) &#123;&#125; * &#125;; */class Solution &#123;public:    ListNode* reverseList(ListNode* head) &#123;        ListNode* newHead = (ListNode*)malloc(sizeof(ListNode));        newHead-&gt;next = NULL;                ListNode* nowNode = head;        ListNode* nextNode;        while(nowNode)&#123;            nextNode = nowNode-&gt;next;            nowNode-&gt;next = newHead-&gt;next;            newHead-&gt;next = nowNode;            nowNode = nextNode;        &#125;        return newHead-&gt;next;            &#125;&#125;;\n\n\n","categories":["数据结构与算法","刷题记录"],"tags":["链表","数据和结构与算法","打卡"]},{"title":"合并两个排序的链表","url":"/2021/11/3d9c02fb16c1.html","content":"题目来源www.acwing.com/problem/content/34/\n\n题目输入两个递增排序的链表，合并这两个链表并使新链表中的结点仍然是按照递增排序的。\n\n样例输入：1-&gt;3-&gt;5 , 2-&gt;4-&gt;5输出：1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;5\n\n\nAC代码/** * Definition for singly-linked list. * struct ListNode &#123; *     int val; *     ListNode *next; *     ListNode(int x) : val(x), next(NULL) &#123;&#125; * &#125;; */class Solution &#123;public:    ListNode* merge(ListNode* l1, ListNode* l2) &#123;        ListNode* newNode = (ListNode*)malloc(sizeof(ListNode));        newNode-&gt;next = NULL;                ListNode* nodeL1 = l1;        ListNode* nodeL2 = l2;        ListNode* endNode = newNode;        while(nodeL1!= NULL&amp;&amp;nodeL2!=NULL)&#123;                        if(nodeL1-&gt;val&lt;= nodeL2-&gt;val)&#123;                endNode-&gt;next = nodeL1;                endNode = nodeL1;                nodeL1 = nodeL1-&gt;next;            &#125;else&#123;                endNode-&gt;next = nodeL2;                endNode = nodeL2;                nodeL2 = nodeL2-&gt;next;            &#125;        &#125;                if(nodeL1!=NULL)&#123;            endNode-&gt;next = nodeL1;        &#125;else if(nodeL2!=NULL)&#123;            endNode-&gt;next = nodeL2;        &#125;else&#123;            endNode-&gt;next = NULL;        &#125;        return newNode-&gt;next;    &#125;&#125;;\n\n\n","categories":["数据结构与算法","刷题记录"],"tags":["链表","数据和结构与算法","打卡"]},{"title":"地牢大师","url":"/2021/11/6f2d94404767.html","content":"题目来源https://www.acwing.com/problem/content/1098/\n\n题目你现在被困在一个三维地牢中，需要找到最快脱离的出路！\n地牢由若干个单位立方体组成，其中部分不含岩石障碍可以直接通过，部分包含岩石障碍无法通过。\n向北，向南，向东，向西，向上或向下移动一个单元距离均需要一分钟。\n你不能沿对角线移动，迷宫边界都是坚硬的岩石，你不能走出边界范围。\n请问，你有可能逃脱吗？\n如果可以，需要多长时间？\n输入格式输入包含多组测试数据。\n每组数据第一行包含三个整数 L,R,C 分别表示地牢层数，以及每一层地牢的行数和列数。\n接下来是 L 个 R 行 C 列的字符矩阵，用来表示每一层地牢的具体状况。\n每个字符用来描述一个地牢单元的具体状况。\n其中, 充满岩石障碍的单元格用”#”表示，不含障碍的空单元格用”.”表示，你的起始位置用”S”表示，终点用”E”表示。\n每一个字符矩阵后面都会包含一个空行。\n当输入一行为”0 0 0”时，表示输入终止。\n输出格式每组数据输出一个结果，每个结果占一行。\n如果能够逃脱地牢，则输出”Escaped in x minute(s).”，其中X为逃脱所需最短时间。\n如果不能逃脱地牢，则输出”Trapped!”。\n数据范围1≤L,R,C≤100\n输入样例：3 4 5S.....###..##..###.#############.####...###########.#######E1 3 3S###E####0 0 0\n\n输出样例：Escaped in 11 minute(s).Trapped!\n\nAC代码#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;queue&gt;using namespace std;const int MAX = 103;int moving[6][3] = &#123;&#123;0,0,1&#125;,&#123;0,0,-1&#125;,&#123;0,1,0&#125;,&#123;0,-1,0&#125;,&#123;1,0,0&#125;,&#123;-1,0,0&#125;&#125;;//偏移量char map[MAX][MAX][MAX];int a,b,c;      //地图最大值，a最大层数，b最大行数，c最大列数typedef struct&#123;    int x,y,z;  //x,y,z坐标    int lev;    //到达该点所用时间&#125;Loc;   //定义位置结构体Loc start;  //存储开始位置&#x27;S&#x27;所在坐标//判断位置是否越界bool isTrue(Loc loc)&#123;    return loc.x&gt;=0&amp;&amp;loc.x&lt;a&amp;&amp;loc.y&gt;=0&amp;&amp;loc.y&lt;b&amp;&amp;loc.z&gt;=0&amp;&amp;loc.z&lt;c;&#125;//宽搜函数void bfs()&#123;    queue&lt;Loc&gt; q;       //宽搜其实就是层次遍历，所以用到队列    q.push(start);      //将开始位置入队    map[start.x][start.y][start.z] = &#x27;#&#x27;;   //初始化开始位置为已经访问    start.lev = 0;                          //初始化到达起点位置所需时间为0    while(!q.empty())&#123;          Loc now,next;               //定义当前所在位置和下一位置        now = q.front();            //将对首元素取出，作为当前所在位置        q.pop();                    //到达该位置后将该位置出队        for(int i = 0; i &lt; 6; i++)&#123;            //遍历上下左右前后6个方向            next.x = now.x + moving[i][0];  //下一位置坐标=当前位置坐标+偏移量            next.y = now.y + moving[i][1];            next.z = now.z + moving[i][2];            next.lev = now.lev + 1;         //到达下一位置时间=当前时间+1            //如果下一位置合理(没有地图越界)            if(isTrue(next))&#123;                //如果下一位置不可通过，或者已经到达过了就不在访问                if(map[next.x][next.y][next.z] == &#x27;#&#x27;) continue;                //如果下一位置可以访问                if(map[next.x][next.y][next.z] == &#x27;.&#x27;)&#123;                    q.push(next);       //将下一位置入队，等待下次出队访问                    map[next.x][next.y][next.z] = &#x27;#&#x27;;      //设置下一位置已经访问                &#125;                //如果下一位置为出口                if(map[next.x][next.y][next.z] == &#x27;E&#x27;)&#123;                    //直接打印时所需要花费的时间                    cout&lt;&lt;&quot;Escaped in &quot;&lt;&lt;next.lev&lt;&lt;&quot; minute(s).&quot;&lt;&lt;endl;                    return; //结束遍历                &#125;            &#125;        &#125;    &#125;    cout&lt;&lt;&quot;Trapped!&quot;&lt;&lt;endl;&#125;int main()&#123;    while(cin&gt;&gt;a&gt;&gt;b&gt;&gt;c,a||b||c)&#123;        memset(map,&#x27;#&#x27;,sizeof(map));        for(int i = 0; i &lt; a; i++)&#123;            for(int j = 0; j &lt; b; j++)&#123;                for(int k = 0; k &lt; c; k++)&#123;                    cin&gt;&gt;map[i][j][k];                    if(map[i][j][k] == &#x27;S&#x27;) &#123;                        start.x = i;                        start.y = j;                        start.z = k;                    &#125;                &#125;                getchar();            &#125;            getchar();        &#125;                bfs();    &#125;    return 0;&#125;\n","categories":["数据结构与算法","刷题记录"],"tags":["数据和结构与算法","打卡","bfs"]},{"title":"小平方","url":"/2021/11/3ab222bab39a.html","content":"题目来源www.acwing.com/problem/content/34/\n\n题目小蓝发现，对于一个正整数 n 和一个小于 n 的正整数 v，将 v 平方后对 n 取余可能小于 n 的一半，也可能大于等于 n 的一半。\n请问，在 1 到 n−1 中，有多少个数平方后除以 n 的余数小于 n 的一半。\n例如，当 n&#x3D;4 时，1,2,3 的平方除以 4 的余数都小于 4 的一半。\n又如，当 n&#x3D;5 时，1,4 的平方除以 5 的余数都是 1，小于 5 的一半。\n而 2,3 的平方除以 5 的余数都是 4，大于等于 5 的一半。\n\n输入格式输入一行包含一个整数 n。\n\n输出格式输出一个整数，表示满足条件的数的数量。\n\n数据范围1≤n≤10000\n\n输入样例5\n\n\n输出样例2\n\n\nAC代码\n虽然是水题但是有一点需要注意，(n_n)%m&lt;(m&#x2F;2)会造成错误,比如(2_2)%9&lt;(9&#x2F;2)结果为false,应该改为(n_n)%m&lt;(m&#x2F;2.0)或者(n_n)%m*2&lt;m.\n\n#include &lt;iostream&gt;using namespace std;int main()&#123;    int n;    cin&gt;&gt;n;    int m = n;    int count = 0;    while(--n)&#123;        //虽然是水题但是有一点需要注意，(n*n)%m&lt;(m/2)会造成错误        //比如(2*2)%9&lt;(9/2)结果为false        //应该改为(n*n)%m&lt;(m/2.0)或者(n*n)%m*2&lt;m        if((n*n)%m&lt;(m/2.0))   count++;     &#125;    cout&lt;&lt;count&lt;&lt;endl;    return 0;&#125;\n","categories":["数据结构与算法","刷题记录"],"tags":["数据和结构与算法","打卡","枚举"]},{"title":"整数拼接","url":"/2021/11/1e71238371cc.html","content":"题目来源www.acwing.com/problem/content/2070/\n\n题目给定一个长度为 n 的数组A1,A2,···,An。\n你可以从中选出两个数 Ai 和 Aj(i 不等于 j)，然后将 Ai 和 Aj 一前一后拼成一个新的整数。\n例如 12 和 345 可以拼成 12345 或 34512。\n注意交换 Ai 和 Aj 的顺序总是被视为 2 种拼法，即便是 Ai&#x3D;Aj 时。\n请你计算有多少种拼法满足拼出的整数是 K 的倍数。\n\n输入格式第一行包含 22 个整数 nn 和 KK。\n第二行包含 nn 个整数 A1,A2,⋅⋅⋅,AnA1,A2,···,An。\n\n输出格式一个整数代表答案。\n数据范围1≤n≤1051≤n≤105,\n1≤K≤1051≤K≤105,\n1≤Ai≤1091≤Ai≤109\n\n输入样例4 21 2 3 4\n\n\n输出样例6\n\n\n暴力dfs枚举法\n能过一部分数据\n\n#include &lt;iostream&gt;using namespace std;typedef long long LL;const int MAX = 10003;LL num[MAX];bool isUsed[MAX];LL used[3];int n,k;int count;void dfs(int lev)&#123;    if(lev &gt; 2)&#123;        LL temp2 = used[2];        LL temp1 = used[1];        LL chen = 1;        do&#123;            chen *= 10;        &#125;while(temp2/=10);        temp1 = (used[1]%k)*(chen%k)%k;        temp2 = used[2]%k;        //cout&lt;&lt;used[1]&lt;&lt;used[2]&lt;&lt;&quot;:&quot;&lt;&lt;temp1&lt;&lt;&quot;,&quot;&lt;&lt;temp2&lt;&lt;endl;        if((temp1+temp2)%k== 0)&#123;            count++;        &#125;        return;    &#125;        for(int i=0;i&lt;n;i++)&#123;        if(!isUsed[i])&#123;        \tisUsed[i] = true;            used[lev] = num[i];            dfs(lev+1);            isUsed[i] = false;        &#125;    &#125;&#125;int main()&#123;        cin&gt;&gt;n&gt;&gt;k;    for(int i = 0;i&lt;n;i++)&#123;        cin&gt;&gt;num[i];    &#125;    dfs(1);    cout&lt;&lt;count&lt;&lt;endl;    return 0;&#125;\n\n\n哈希表预处理再枚举\n空间换时间\n\n\n其中用到了一些数论的取模公式：\n\n\n-(a+b)%c &#x3D; ((a%c)+(b%c))%c\n\n\n-(ab)%c &#x3D; (a%c)(b%c)%c\n\n\n-(a-b)%c &#x3D; ((a%c-b%c)+c)%c\n\n#include &lt;iostream&gt;#include &lt;cstring&gt;using namespace std;typedef long long LL;const int MAX = 100005;LL num[MAX];int hashTable[11][MAX];//题目核心num[j]*10^leni%k = -num[i]%kint main()&#123;    int n,k;    cin&gt;&gt;n&gt;&gt;k;    for(int i = 0;i&lt;n;i++)&#123;        cin&gt;&gt;num[i];    &#125;        //预处理：任意一个num*10^leny%k的余数为x的数量(1&lt;y&lt;10)    for(int i = 0;i&lt;n;i++)&#123;        LL chen = 1;        for(int j = 1;j&lt;11;j++)&#123;            chen *= 10;            int yu = ((num[i]%k)*(chen%k))%k;            hashTable[j][yu]++;        &#125;    &#125;        //枚举查找    LL res = 0;    for(int i = 0;i&lt;n;i++)&#123;        //-num[i]%k = (0+(-num[i]))%k = ((0%k)+(-num[i]%k))%k        int len = to_string(num[i]).size();        int yu = (k-num[i]%k)%k;        res +=hashTable[len][yu];        //判断是否存在选择自己与自己组合的情况-&gt;num[j]*10^leni%k = -num[i]%k        LL chen = 1;        while(len--)&#123;            chen*=10;        &#125;        if(yu == ((num[i]%k)*(chen%k))%k) res--;    &#125;            cout&lt;&lt;res&lt;&lt;endl;    return 0;&#125;\n\n\n","categories":["数据结构与算法","刷题记录"],"tags":["数据结构与算法","打卡","hash表"]},{"title":"日志统计","url":"/2021/11/f2b0363f449b.html","content":"题目来源www.acwing.com/problem/content/1240/\n\n题目小明维护着一个程序员论坛。现在他收集了一份”点赞”日志，日志共有 N 行。\n其中每一行的格式是：\nts id\n\n表示在 ts 时刻编号 id 的帖子收到一个”赞”。\n现在小明想统计有哪些帖子曾经是”热帖”。\n如果一个帖子曾在任意一个长度为 D 的时间段内收到不少于 K 个赞，小明就认为这个帖子曾是”热帖”。\n具体来说，如果存在某个时刻 T 满足该帖在 [T,T+D) 这段时间内(注意是左闭右开区间)收到不少于 K 个赞，该帖就曾是”热帖”。\n给定日志，请你帮助小明统计出所有曾是”热帖”的帖子编号。\n输入格式第一行包含三个整数 N,D,K。\n以下 N 行每行一条日志，包含两个整数 ts 和 id。\n\n输出格式按从小到大的顺序输出热帖 id。\n每个 id 占一行。\n\n数据范围$1≤K≤N≤10^5$,\n$0≤ts,id≤10^5$,\n$1≤D≤10000$\n\n输入样例7 10 20 10 1010 1010 19 1100 3100 3\n\n\n输出样例13\n\nAC代码\n算法思路：\n\n\n对于同一个帖子，我们可以按时刻进行排序，然后维护一个队列，每要入队一个元素时就判断，以队首为起始时刻以待加入队列元素为截止时刻的时间段是否满足题目要求的[T,T+D)时间段。如果不满足就将该队首元素出队，以队列中下一元素为起始时刻，以待加入队列元素为截止时刻，继续判断，如此循环，直到队为空或者在队中找到一个元素以其作为起始时刻以待加入元素为结束时刻的时间段满足题目要求的[T,T+D)，那么就将待加入元素加入队列，加入后再进行判断，如果队列中元素已经存在K个元素，则该帖子满足条件。\n\n\n样例模拟：\n\n1号帖子：1号帖子在0，9，10三个时刻获得点赞，首先将0时刻加入队列，当9时刻想加入队列时，进行判断0-9这个时间段是否满足要求[0-10)，通过判断可以知道是满足的所以将9时刻加入队中，然后进行判断队中元素是否满足点赞数k&#x3D;2，也是满足的，所以帖子1是热帖\n10号帖子：10号帖子在0，10两个时刻获得点赞，首先将0时刻加入队列，当10时刻想加入队列时，进行判断0-10这个时间段是否满足要求[0-10)，通过判断可以知道是不满足，所以将队首0时刻出队。出队后队为空，将待加入元素10时刻加入队列，随后再进行判断，队列中元素只有1个，不满足条件，进入下一次循环，但是已经没有新的元素加入了所以10号帖子不满足。\n#include &lt;iostream&gt;#include &lt;queue&gt;#include &lt;algorithm&gt;using namespace std;const int MAX = 100005;typedef pair&lt;int,int&gt; PII;  //(帖子id,点赞时刻ts)queue&lt;PII&gt; p;               //维护一个队列PII piis[MAX];              //储存日志int ans[MAX];               //存储结果的数组int main()&#123;    int n,d,k;    cin&gt;&gt;n&gt;&gt;d&gt;&gt;k;    for(int i = 0; i &lt; n; i++)        cin&gt;&gt;piis[i].second&gt;&gt;piis[i].first;    sort(piis,piis+n);  //sort默认对x升序排序x相同对y升序排序，我这里x存的是帖子id所以是先按照帖子id进行排序，同一帖子按照时刻排序    p.push(piis[0]);    //先将第一个元素入队    for(int i = 1;i&lt;n;i++)&#123; //遍历每一个帖子的每一时刻，其实对于一个帖子已经判断满足了条件那么其他时刻的点赞就不用在判断了，我这里没写这个逻辑        if(piis[i].first != piis[i-1].first )&#123;  //这里是分辨不同帖子            //如果上一帖子id与当前枚举到的帖子id相同，则将队列清空            while(!p.empty()) p.pop();            p.push(piis[i]);        &#125;else&#123;            //如果是同一帖子：            if(piis[i].second-p.front().second&lt;d)&#123;//判断以队首元素为开始时刻，以待加入元素为结束时刻的时间段是否满足条件                p.push(piis[i]);        //满足则入队            &#125;else&#123;                      //不满足循环出队，直到队空或找到满足条件的元素                while(!p.empty()&amp;&amp;piis[i].second-p.front().second&gt;=d)&#123;                    p.pop();                &#125;                p.push(piis[i]);        //循环出队后将待加入元素入队            &#125;            if(p.size() &gt;= k) ans[piis[i].first]++; //判断队中元素是否满足条件，满足则在结果数组中进行记录        &#125;    &#125;    for(int i = 0;i&lt;MAX;i++)&#123;        //对结果数组进行遍历，下标表示帖子id        if(ans[i] != 0) cout&lt;&lt;i&lt;&lt;endl;    &#125;    return 0;&#125;\n","categories":["数据结构与算法","刷题记录"],"tags":["栈","数据和结构与算法","打卡"]},{"title":"最长上升子序列问题","url":"/2021/11/f7f9594be25c.html","content":"题目来源https://www.acwing.com/problem/content/897/\n\n题目给定一个长度为 N 的数列，求数值严格单调递增的子序列的长度最长是多少。\n输入格式第一行包含整数 N。\n第二行包含 N 个整数，表示完整序列。\n输出格式输出一个整数，表示最大长度。\n数据范围1≤N≤1000，\n$−10^9$≤数列中的数≤$10^9$\n输入样例73 1 2 1 8 5 6\n\n输出样例4\n\ndp问题解决思路状态表示dp[i]某长度为i的序列的最后一位元素，比如1，2，6序列则可用状态dp[3]来表示 &#x3D; 6\n状态dp[i]转移到dp[i+1]对于小于最长子序列长度的所有子序列状态，有两种可能\n\ni为最长子序列长度时，这时候dp[i]转移到dp[i+1]即是在dp[i+1]所表示序列的基础上加上一个元素，最长序列长度加1。\n\ni不为最长子序列长度时，这时候dp[i]转移到dp[i+1]即是更新dp[i+1]所表示的序列考虑一个新元素num\n\n对于情况(1)，只要大与最长上升子序列即可完成状态转移，dp[i+1] &#x3D; num，比如dp[3]表示的序列为1，2，4，且最长子序列长度就为3，对于新元素5那么dp[4] &#x3D; 5，所代表的序列就是1，2，4，5,最长序列长度加1\n对于情况(2)，如果新元素num比待更新的dp[i+1]小，则由dp[i]加上新元素对dp[i+1]进行更新如果大则不更新比较好，我们以较小数结尾肯定比以较大数结尾对后续子串的作用更大。比如原dp[3]表示的子序列是1,2,4，dp[4]表示的子序列是1,2,4,8现在来了新元素5对于dp[3]转移到dp[4],就是将1，2，4加上新元素5更新dp[4],即dp[4]从原来的8变成了5.反之dp[4]等于5肯定比dp[4] &#x3D; 8好啊，因为，从原来要比8大的数才能增加最长序列长度，变成只需要大于5就行！\n\n\n\n状态初始化情况1满足的条件是num&gt;dp[i],情况2满足的条件是num&gt;dp[i]且num&lt;dp[i+1]。所以如果我们将dp数组默认值都设置为最大值，两种情况就可以合并为情况2来考虑。只需要特殊判断一下满足条件时i是否等于最大上升序列长度，如果是则更新最长上升序列长度\nAC代码#include &lt;iostream&gt;#include &lt;climits&gt;#include &lt;cstring&gt;using namespace std;int main()&#123;    int n,len = 0,dp[1004];    cin&gt;&gt;n;    //默认状态数组为最大值，都两种状态变一种状态考虑    for(int i = 1; i &lt; 1004; i++) dp[i] = INT_MAX;        dp[0] = INT_MIN;    //我们默认最长子序列长度为0，dp[0]没意义设为最小值    for(int i = 0;i&lt;n;i++)&#123;        int num;        cin&gt;&gt;num;        //每次读入一个新元素        for(int j = 0;j&lt;=len;j++)&#123;            //从0开始遍历到最长子串长度            if(num&gt;dp[j]&amp;&amp;num&lt;dp[j+1])&#123;                //统一用情况2考虑                dp[j+1] = num;//状态更新                if(j == len) len++; //特殊判断一下情况1，如果情况1就更新最长序列长度            &#125;         &#125;    &#125;    cout&lt;&lt;len;    return 0;&#125;\n","categories":["数据结构与算法","刷题记录"],"tags":["数据和结构与算法","DP","打卡","最长上升子序列"]},{"title":"算法题之栈的压入、弹出序列","url":"/2021/11/071f90d13652.html","content":"题目来源www.acwing.com/problem/content/40/\n\n题目输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否可能为该栈的弹出顺序。\n假设压入栈的所有数字均不相等。\n例如序列 1,2,3,4,5 是某栈的压入顺序，序列 4,5,3,2,1 是该压栈序列对应的一个弹出序列，但 4,3,5,1,2 就不可能是该压栈序列的弹出序列。\n\n注意若两个序列长度不等则视为并不是一个栈的压入、弹出序列。若两个序列都为空，则视为是一个栈的压入、弹出序列。\n\n样例输入：[1,2,3,4,5]      [4,5,3,2,1]输出：true\n\n\n思路以1，2，3，4，5为例，题中所说入栈顺序是指，**如果现在3入栈那么在3入栈之前1，2一定已经入栈(但不一定仍在栈中)**；\n我们先模拟两个出栈顺序，找出不同点与规律。\n\n例如出栈顺序可为1，2，3，4，5，那么出入栈的操作为：1先入栈然后出栈，2入栈然后出栈（这时栈为空），3入栈然后出栈，4入栈然后出栈，4入栈然后出栈；如果出栈顺序为1，2，3，5，4，那么出入栈的操作为：1先入栈然后出栈，2入栈然后出栈，3入栈然后出栈，4入栈，5入栈然后出栈，4出栈；\n\n一个出栈顺序是1，2，3，4，5，而另一个是1，2，3，5，4.通过对比过程我们可以知道一个是4入栈后出栈，一个是4入栈后但没有出栈而是继续入栈。所以，对于同一个元素入栈后，有两种操作选择，继续入栈和出栈。这时我们可以画一颗二叉树，每一条路就是我们可以选择的方案。题中并没有让我们求所有方案，只给我们一种方案去判断，所以我们只需要根据出栈顺序去模拟该进行的是入栈还是出栈操作就行了。简单来说就是给你了路标，你跟着走，走通了就是正确的路标走不通就是错误的路标。接下来继续看例子，入栈顺序仍是1，2，3，4，5\n\n第一条路：入栈顺序1，2，3，4，5，出栈顺序1，2，5，4，3\n\n\n模拟过程：首先1入栈，入栈后有两条路可以选，出栈或者继续入栈，这时看地图(给的出栈顺序)第一个元素是1，说明我们要选择的路是1出栈；然后继续2入栈，看地图(出栈顺序)第二个元素是2，说明我们要选择的路是2出栈；然后继续3入栈，看地图(出栈顺序)第三个元素是5，说明我们要选择的路不是出栈而是继续入栈（这时栈中有元素3）；然后继续4入栈，看地图(出栈顺序)第三个元素是5，说明我们要选择的路不是出栈而是继续入栈（这时栈中有元素3，4）；然后继续5入栈，看地图(出栈顺序)第三个元素是5，说明我们要选择的路是出栈刚刚入栈的5，出栈后栈中还有元素3，4，看地图(出栈顺序)第四个元素是4，所以我们再出栈，出栈后栈中还有元素3，看地图(出栈顺序)第五个元素是3，所以我们再出栈.最后模拟完毕，路走通了。\n\n\n第二条路：入栈顺序1，2，3，4，5，出栈顺序1，2，5，3，4\n\n\n模拟过程：首先1入栈，入栈后有两条路可以选，出栈或者继续入栈，这时看地图(给的出栈顺序)第一个元素是1，说明我们要选择的路是1出栈；然后继续2入栈，看地图(出栈顺序)第二个元素是2，说明我们要选择的路是2出栈；然后继续3入栈，看地图(出栈顺序)第三个元素是5，说明我们要选择的路不是出栈而是继续入栈（这时栈中有元素3）；然后继续4入栈，看地图(出栈顺序)第三个元素是5，说明我们要选择的路不是出栈而是继续入栈（这时栈中有元素3，4）；然后继续5入栈，看地图(出栈顺序)第三个元素是5，说明我们要选择的路是出栈刚刚入栈的5，出栈后栈中还有元素3，4，看地图(出栈顺序)第四个元素是3，所以我们不能再出栈，需要入栈但是1，2，3，4，5都已经入栈了没有元素了，所以路走不通。\n\n\nAC代码class Solution &#123;    public boolean isPopOrder(int [] pushV,int [] popV) &#123;        //如果长度不一样直接return false        if(pushV.length != popV.length)&#123;            return false;        &#125;        //如果输入输出栈为空则直接return true        if(pushV.length == 0 &amp;&amp; popV.length == 0)&#123;            return true;        &#125;        Stack&lt;Integer&gt; s=new Stack&lt;&gt;();        int j = 0;  //定义j指向popV数组，存储判断到了哪个元素        //循环入栈，如果栈顶元素与出栈数组popV的所指向的元素相等则出栈该元素，如果栈不为空则继续尝试出栈操作。无法出栈则继续循环入栈直到无法入栈        for(int i = 0;i&lt;pushV.length;i++)&#123;            s.push(pushV[i]);            while(!s.isEmpty()&amp;&amp;s.peek() == popV[j])&#123;                j++;                s.pop();            &#125;        &#125;        //最后模拟的栈中应该为空，如果为空则出栈顺序符合，反之不符合        if(s.isEmpty())&#123;            return true;        &#125;        return false;    &#125;&#125;\n\n\n","categories":["数据结构与算法","刷题记录"],"tags":["数据结构与算法","栈","打卡"]},{"title":"蓝桥杯-子串分值和","url":"/2021/11/bdfb1b20a4e6.html","content":"题目描述对于一个字符串 S，我们定义 S 的分值 f(S) 为 S 中出现的不同的字符个数。\n例如 f(“aba”)&#x3D;2，f(“abc”)&#x3D;3,f(“aaa”)&#x3D;1 。\n现在给定一个字符串 S[0..n−1]（长度为 n），请你计算对于所有 S 的非空子串 Si..j，f(S[i..j]) 的和是多少。\n子串\n首先了解什么是子串,一个字符串 s 被称作另一个字符串 S 的子串，表示S&#x3D;XsY。\n\n例如abcc的子串有\n{\n空串\na\nb ab\nc bc abc\nc cc bcc abcc\n}\n\n为什么会有两个子串c?\n第一个子串c前面是_ab_后面是_c_，第二个子串c前面是_abc_后面是空，都满足定义！\n\n思路我们可以用状态转移的方法来思考，状态的定义是当前字符串所有子串的集合(例如:ab,当前字符串子串集合为{a,b,ab,空串})，当新来一个字母b接到字符串后方时，子串集合可以由两部分转移\n\n老的子串集合直接转移,即{a,b,ab,空串} \n新生成的子串,这部分子串可分为两部分\n\n\n新来的字母单独做为一个子串,即字母{b} \n可以将新字母直接接在旧子串后面形成新子串,即直接接在前一个字母b后面形成{bb,abb}\n\n所以当前状态abb所表示的新集合为:接在后面的集合+新字母单独做子串集合+旧集合，即{bb,abb}+{b}+{a,b,ab,空串}&#x3D;{a,b,ab,空串b,bb,abb}\n我们再来看看在转移过程中,子串数值的变化,仍然以上面的ab新添加b为例子,设旧子串集合{a,b,ab,空串}的总数值为sum0,新子串集合的总数值为x,最终形成的子串集合为sum1,所以\n\nsum1&#x3D;sum0+x -&gt; sum &#x3D; sum + x\n\n递推公式已经推出,我们来看看这个x的数值是怎样变化的,{bb,abb}它是由旧集合中以最后一个字母结尾的子串{b,ab}再加上新字符b形成的,根据题目的定义如果新添加的字符前面已经存在，那么数值不变仍然为前面的子串的数值，反之则在前面子串基础上加上新字符的数值即1.回到x上来,从{b,ab}到{bb,abb},我们设{a,ab}数值为x0,{bb,abb}数值为x1,可以知道x1&#x3D;x0+增量c,增量c是由新加字符决定的，也就是前面有多少个不含新字符的子串数量,这里的增量为0，因为b,ab都含有新加字符b.现在x的递推公式也得到了,最后别忘了新来的字母单独做为一个子串,即字母{b}。\n\nx1 &#x3D; x0 + 增量 + 1\n\n最后我们可以开一个数组st[i]来记录当前状态不含某个字符i的子串数量,当新加一个字符时，我们直接查询即可得到增量,添加完字符后我们对st数组进行更新即可\n\nx &#x3D; x + st[i] + 1\n\nAC代码#include &lt;iostream&gt;#include &lt;cstring&gt;using namespace std;char chs[100005];   //用来存储字符串int st[30]; //存储不包含i字符的子串数void update(char ch)&#123;   //在旧字符串后面加上新字母后，更新st数组    int aim = ch-&#x27;a&#x27;;   //计算索引,a对应下标0，b对应1以此类推    st[aim] = 0;    //由于在可加的所有子串末尾新加了字母ch，所以前面的所有子串都不包含新加的字母    for(int i = 0;i&lt;30;i++)&#123;    //遍历26个字母        if(i != aim)&#123;              st[i]++;    //新来的字母单独做为一个子串，所以需要加1        &#125;    &#125;&#125;int main()&#123;    long long sum = 0;  //用于记录子串数值总和sum    long long x = 0;  //用于记录新生成的子串数值和    cin&gt;&gt;chs;    int n = strlen(chs);    for(int i = 0;i&lt;n;i++)&#123;        x = x + st[chs[i]-&#x27;a&#x27;] + 1;  //文章中的x1=x0+增量        sum = sum + x;   //文章中的sum1=sum0+1+x.        update(chs[i]);     &#125;    cout&lt;&lt;sum;    return 0;&#125;\n","categories":["数据结构与算法","刷题记录"],"tags":["数据结构与算法","打卡"]}]